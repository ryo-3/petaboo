# ボード紐づけデータ取得一本化リファクタリング計画

## 🎯 目的

ボード紐づけデータの取得を親コンポーネントに集約し、子コンポーネントはpropsのみ使用することで、データフローを明確化し安定性を向上

## 🔍 現状の問題点

### 1. データソースの分散

- `preloadedBoardItems` (親から渡される)
- `useItemBoards` / `useTeamItemBoards` (子コンポーネントでAPI直接取得)
- `selectedBoardIds` (ローカル状態)

→ **どれを信用すべきか不明確で、バグの温床**

### 2. チーム/個人の判定ロジックが分散

````typescript
// API側で判定
const isTeamItem = await db.select(...).from(teamMemos)...

// フロント側でも判定
if (teamMode) { return teamItemBoards; }

// URLパスでも判定
window.location.pathname.includes("/team/")
```.claude/完了済計画書/ボード紐づけデータ取得一本化計画.md

### 3. 繰り返し発生する問題
- ボード紐づけが表示されない
- チーム/個人でテーブル切り替え漏れ
- 新規作成時のボード表示の不整合

---

## 📍 影響範囲

### 削除するフック呼び出し
1. **MemoEditor** - `useTeamItemBoards` 削除
2. **TaskEditor** - `useItemBoards`, `useTeamItemBoards` 削除
3. **ItemFilterWrapper** - 確認が必要

### 親コンポーネント（データ取得を追加）
1. **MemoScreen** - 個人メモ一覧
2. **TaskScreen** - 個人タスク一覧
3. **BoardDetailScreen** - ボード詳細（BoardRightPanel経由）
4. **CreateScreen** - 新規作成画面

### エディターProps拡張
```typescript
// MemoEditor / TaskEditor
interface EditorProps {
  // 既存
  preloadedBoards: Board[];
  preloadedBoardItems: BoardItem[];

  // 追加
  itemBoards: Board[];  // このアイテムに紐づくボード（API取得済み）
}
````

---

## 🔧 リファクタリング手順

### フェーズ1: 親コンポーネントでAPI取得追加（既存動作維持）

#### 1-1. MemoScreen

```typescript
// 個人モード
const { data: personalItemBoards } = useItemBoards(
  "memo",
  selectedMemo?.originalId || selectedMemo?.id?.toString()
);

// チームモード
const { data: teamItemBoards } = useTeamItemBoards(
  teamId || 0,
  "memo",
  selectedMemo?.originalId || selectedMemo?.id?.toString()
);

const currentItemBoards = teamMode ? teamItemBoards : personalItemBoards;

// MemoEditorに渡す
<MemoEditor
  itemBoards={currentItemBoards || []}
  // ... 他のprops
/>
```

#### 1-2. TaskScreen

同様の処理を追加

#### 1-3. BoardRightPanel

既に`allBoards`を取得済みなので、アイテム別のボードのみ追加

```typescript
// BoardRightPanel内で取得
const { data: personalMemoBoards } = useItemBoards(
  "memo",
  selectedMemo?.originalId || selectedMemo?.id?.toString()
);
const { data: teamMemoBoards } = useTeamItemBoards(
  teamId || 0,
  "memo",
  selectedMemo?.originalId || selectedMemo?.id?.toString()
);
const memoItemBoards = teamMode ? teamMemoBoards : personalMemoBoards;

// 同様にタスク用も

// MemoEditor / TaskEditorに渡す
<MemoEditor
  itemBoards={memoItemBoards || []}
  // ...
/>
```

---

### フェーズ2: エディター側のAPI取得削除

#### 2-1. MemoEditor

```typescript
// 削除
// const { data: teamItemBoards = [] } = useTeamItemBoards(...)

// propsから使用
const itemBoards = useMemo(() => {
  if (!memo || memo.id === 0) return [];
  return props.itemBoards; // propsから取得
}, [memo, props.itemBoards]);
```

#### 2-2. TaskEditor

同様の変更

---

### フェーズ3: displayBoards計算の簡素化

現在の複雑なロジックを整理：

```typescript
// 統一されたdisplayBoards計算
const displayBoards = useMemo(() => {
  // DBから取得したボード
  const saved = itemBoards.filter(
    (b) => !initialBoardId || b.id !== initialBoardId,
  );

  // 選択中のボード
  const selected = selectedBoardIds
    .map((id) => preloadedBoards.find((b) => b.id === id))
    .filter((b): b is Board => b !== undefined)
    .filter((b) => !initialBoardId || b.id !== initialBoardId);

  // マージ（重複排除）
  const merged = [...saved];
  selected.forEach((board) => {
    if (!merged.some((b) => b.id === board.id)) {
      merged.push(board);
    }
  });

  return merged;
}, [itemBoards, selectedBoardIds, preloadedBoards, initialBoardId]);
```

---

## ✅ テスト項目

### 個人モード

#### メモ一覧

- [ ] 既存メモを開く → ボード紐づけ表示
- [ ] 新規メモ作成 → ボード選択 → 保存前にボード表示
- [ ] メモにボード追加 → 保存 → 紐づけが保持される
- [ ] メモからボード削除 → 保存 → 削除が反映される

#### タスク一覧

- [ ] 既存タスクを開く → ボード紐づけ表示
- [ ] 新規タスク作成 → ボード選択 → 保存前にボード表示
- [ ] タスクにボード追加 → 保存 → 紐づけが保持される
- [ ] タスクからボード削除 → 保存 → 削除が反映される

#### ボード詳細

- [ ] ボード詳細でメモを開く → 該当ボードが紐づき表示（initialBoard除外）
- [ ] ボード詳細でタスクを開く → 該当ボードが紐づき表示（initialBoard除外）
- [ ] ボード詳細で新規メモ → ボード選択 → 保存前表示
- [ ] ボード詳細で新規タスク → ボード選択 → 保存前表示

---

### チームモード

#### メモ一覧

- [ ] 既存チームメモを開く → ボード紐づけ表示
- [ ] 新規チームメモ作成 → ボード選択 → 保存前にボード表示
- [ ] チームメモにボード追加 → 保存 → 紐づけが保持される

#### タスク一覧

- [ ] 既存チームタスクを開く → ボード紐づけ表示
- [ ] 新規チームタスク作成 → ボード選択 → 保存前にボード表示
- [ ] チームタスクにボード追加 → 保存 → 紐づけが保持される

#### チームボード詳細

- [ ] チームボード詳細でメモを開く → 該当ボードが紐づき表示
- [ ] チームボード詳細でタスクを開く → 該当ボードが紐づき表示

---

### エッジケース

- [ ] ボード詳細 → アイテム開く → 別ボード追加 → 保存 → 両方表示
- [ ] メモ/タスク切り替え時のボード表示リセット
- [ ] 削除済みアイテムのボード表示

---

## 🚨 リスク

### 1. パフォーマンス

親での追加API呼び出しによる遅延

**対策**: React Queryのキャッシュ活用（既に設定済み）

### 2. 選択中アイテム変更時の再取得

不要な再取得が発生する可能性

**対策**: `enabled: !!selectedMemo && !!selectedMemo.originalId`

### 3. propsドリリング増加

propsの受け渡しが増える

**対策**: 必要最小限のpropsのみ追加（`itemBoards`のみ）

---

## 📝 実装順序（推奨）

1. **MemoScreen → MemoEditor** （個人モード）
2. **テスト実行** （個人メモの全パターン）
3. **TaskScreen → TaskEditor** （個人モード）
4. **テスト実行** （個人タスクの全パターン）
5. **BoardRightPanel対応** （個人・チーム両方）
6. **テスト実行** （ボード詳細の全パターン）
7. **チームモード対応**
8. **最終テスト** （全パターン）

---

## 📊 期待される効果

### Before（現在）

```
親コンポーネント
  ├─ データ取得A (preloadedBoardItems)
  └─ 子コンポーネント
      ├─ データ取得B (useItemBoards)
      ├─ データ取得C (useTeamItemBoards)
      └─ データ整合性の問題 ❌
```

### After（改善後）

```
親コンポーネント
  ├─ データ取得A (preloadedBoardItems)
  ├─ データ取得B (useItemBoards / useTeamItemBoards)
  └─ 子コンポーネント
      └─ propsのみ使用 ✅
```

### 改善点

- ✅ データフローが明確化
- ✅ デバッグが容易に
- ✅ 同じバグの再発防止
- ✅ チーム/個人の切り替えロジックが一元化

---

## 🔄 今後の改善案（このリファクタリング後）

1. **originalId型の完全統一** - utilsで変換関数を一元化
2. **チーム/個人判定の一元化** - コンテキストで管理
3. **共通Hooks作成** - `useUnifiedItemBoards`のような統一インターフェース

---

## 📅 作成日

2025-10-08

## 📝 ステータス

- [x] レビュー待ち
- [x] 実装中（フェーズ1-3完了）
- [x] **完了**（2025-10-09）

### 完了内容

- ✅ **フェーズ1**: 親コンポーネントでAPI取得追加
  - MemoScreen: ✅ 完了
  - TaskScreen: ✅ 完了
  - BoardDetailScreen: ✅ 完了
  - BoardDetailScreen-3panel（チーム用）: ✅ 完了
- ✅ **フェーズ2**: エディター側での`preloadedItemBoards`優先使用
  - MemoEditor: ✅ 完了
  - TaskEditor: ✅ 完了
- ✅ **フェーズ3**: BoardRightPanelへのprops受け渡し
  - 個人モード: ✅ 完了
  - チームモード: ✅ 完了

### 修正されたバグ

1. ✅ 個人タスクエディターでボード紐づけ未表示 → task-screen.tsx RightPanel修正
2. ✅ チームタスクエディターでボード紐づけ未表示 → board-detail-screen-3panel.tsx 全体修正

## 🔍 デバッグログ追加（2025-10-08）

### 個人タスクでボード取得確認中

**追加したログ:**

1. **task-screen.tsx**

```typescript
console.log("🔍 TaskScreen itemBoards取得", {
  selectedTaskId,
  teamMode,
  personalTaskItemBoards: personalTaskItemBoards?.length,
  teamTaskItemBoards: teamTaskItemBoards?.length,
  itemBoards: itemBoards?.length,
  selectedTask: selectedTask
    ? { id: selectedTask.id, originalId: selectedTask.originalId }
    : null,
});
```

2. **task-editor.tsx**

```typescript
// preloadedItemBoards使用時
console.log("🔍 TaskEditor: preloadedItemBoardsを使用", {
  taskId: task?.id,
  originalId: task?.originalId,
  preloadedItemBoards: preloadedItemBoards.length,
  boards: preloadedItemBoards.map((b) => ({ id: b.id, name: b.name })),
});

// 後方互換ロジック使用時
console.log("🔍 TaskEditor: 後方互換ロジックを使用", {
  taskId: task?.id,
  originalId: task?.originalId,
  initialBoardId,
});
```

**確認ポイント:**

- [x] `selectedTaskId`が正しく取得できているか ✅
- [x] `personalTaskItemBoards`にデータが入っているか ✅
- [x] `preloadedItemBoards`がTaskEditorに渡っているか ✅（RightPanel修正後）
- [x] TaskEditor内で`preloadedItemBoards`が使用されているか ✅

**結果**: 個人タスクエディターは修正完了。RightPanel内のTaskEditorに`preloadedItemBoards`を渡すことで解決。

---

## チームタスクのボード紐づけ問題（2025-10-09）

### 問題

`/team/moricrew/board/board-1759895752133/task/299` でタスクエディターがボード紐づけを表示しない

### 原因

チームボード詳細ページは `board-detail-screen-3panel.tsx` を使用しているが、このファイルには以下が未実装：

1. `useItemBoards` / `useTeamItemBoards` によるデータ取得
2. `completeItemBoards` の計算
3. BoardRightPanelへの `preloadedItemBoards` 受け渡し

### 対処

`board-detail-screen-3panel.tsx` にフェーズ1・2の修正を適用する必要あり
