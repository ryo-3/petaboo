# 競合検出（楽観的ロック）

## 最終更新: 2024-12-09

## ステータス: ✅ 実装済み（PETABOO-55 Step 3）

---

## 概要

チームモードで複数メンバーが同じアイテムを同時編集した際に、データ上書きを防止する仕組み。

```
方式: 楽観的ロック（Optimistic Locking）
- フロント: 更新時に updatedAt を送信
- API: updatedAt を比較、不一致なら 409 Conflict
- フロント: 409 受信時にトーストで通知 + 最新データで更新
```

---

## 動作フロー

```
1. ユーザーAがアイテムを開く（updatedAt: 1000）
2. ユーザーBがアイテムを開く（updatedAt: 1000）
3. ユーザーAが保存（updatedAt: 1000 → 2000 に更新）✅ 成功
4. ユーザーBが保存（updatedAt: 1000 を送信）
   → API側で比較: DB(2000) ≠ クライアント(1000)
   → 409 Conflict を返す
5. ユーザーBに「他のメンバーが変更しました」とトースト表示（5秒）
6. 最新データ（updatedAt: 2000）でUIを自動更新
```

---

## 対象

| 対象         | 競合チェック |
| ------------ | ------------ |
| チームタスク | ✅ あり      |
| チームメモ   | ✅ あり      |
| 個人タスク   | ❌ なし      |
| 個人メモ     | ❌ なし      |
| 削除操作     | ❌ なし      |

**理由**:

- 個人モード: 同時編集がないため不要
- 削除操作: 削除済みなら 404 で十分

---

## 実装箇所

### API側

| ファイル                        | 内容                              |
| ------------------------------- | --------------------------------- |
| `teams/tasks.ts` PUT ハンドラ内 | updatedAt 比較 → 409 + latestData |
| `teams/memos.ts` PUT ハンドラ内 | updatedAt 比較 → 409 + latestData |

```typescript
// 楽観的ロック: updatedAt を抽出して競合チェック
const { updatedAt: clientUpdatedAt, ...rest } = parsed.data;

if (clientUpdatedAt !== undefined) {
  const current = await db.select({ updatedAt }).from(table).where(...).get();

  if (current.updatedAt !== clientUpdatedAt) {
    const latestData = await db.select(...).get();
    return c.json({
      error: "Conflict",
      message: "他のメンバーが変更しました",
      latestData,
    }, 409);
  }
}
```

### フロント側

| ファイル                  | 内容                                |
| ------------------------- | ----------------------------------- |
| `use-simple-item-save.ts` | チームモード保存時に updatedAt 送信 |
| `use-tasks.ts`            | 409 時にトースト + キャッシュ更新   |
| `use-memos.ts`            | 409 時にトースト + キャッシュ更新   |

```typescript
onError: (error: Error & { status?: number; latestData?: Task }) => {
  if (error.status === 409 && error.latestData) {
    showToast(
      "他のメンバーが変更しました。最新の内容を表示します。",
      "warning",
      5000,
    );
    updateItemCache({
      queryClient,
      itemType: "task",
      operation: "update",
      item: error.latestData,
      teamId,
    });
  }
};
```

---

## 後方互換性

- `updatedAt` が送信されない場合はチェックをスキップ
- 古いクライアントでも動作する

---

## 未実装・不十分な点

### 競合チェック未対応のエンティティ

| エンティティ   | 競合チェック | 備考                     |
| -------------- | ------------ | ------------------------ |
| チームタスク   | ✅ 実装済み  |                          |
| チームメモ     | ✅ 実装済み  |                          |
| チームボード   | ❌ 未実装    | ボード名・設定の同時編集 |
| ボードアイテム | ❌ 未実装    | アイテム並び順の同時変更 |
| ボードカテゴリ | ❌ 未実装    | カテゴリ名の同時編集     |

### フォーム関連の課題

| 課題                     | 現状                 | 対応案                                      |
| ------------------------ | -------------------- | ------------------------------------------- |
| 競合時のフォーム処理     | 警告のみ、入力は破棄 | 下書き保存 or フォーム上書き                |
| refetch後のupdatedAt問題 | 古いupdatedAtで保存  | フォームにupdatedAt持たせる or 再取得時更新 |

### その他

| 課題                 | 現状         | 対応案                 |
| -------------------- | ------------ | ---------------------- |
| 競合時のマージUI     | なし         | diff表示 + 手動マージ  |
| 競合頻度のログ・分析 | なし         | 将来的に監視           |
| タグ付け操作の競合   | チェックなし | 優先度低（影響が軽微） |

### 詳細: refetch後のupdatedAt問題

```
1. ユーザーがアイテムを開く（updatedAt: 1000）
2. フォームに updatedAt: 1000 が保持される
3. 定期refetch（60秒）でキャッシュが更新される（updatedAt: 2000）
4. ユーザーが保存 → フォームの古い updatedAt: 1000 を送信
5. 409 Conflict（競合ではないのに）
```

**対応案**:

- フォームコンポーネントで `updatedAt` を `useEffect` で最新化
- または保存時にキャッシュから最新の `updatedAt` を取得

---

## 関連ファイル

- 設計方針: `.claude/開発メモ/キャッシュ設計方針.md`
- 実装Plan: `.claude/fixed-plans/PETABOO-55_step3_競合チェック.md`
