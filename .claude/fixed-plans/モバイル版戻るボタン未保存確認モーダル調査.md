# モバイル版戻るボタン未保存確認モーダル調査Plan

> ⚠️ Codexに実装依頼する際は、以下を厳守すること：
>
> - **既存ファイルを丸ごと再生成させないこと** → Codexへの依頼は必ず **差分（patch形式）** で行う
> - **日本語コメント・文字列を扱う場合はUTF-8前提で依頼すること** → 文字化け防止のため明記する
> - **Codexに git add / git commit を実行させないこと**
> - **完了した場合ファイルを`.claude/fixed-plans` に移動する**

## ✅ 完了報告

**修正日**: 2025-11-20

### 問題の原因

**仮説2が正解**: イベントは発火しているが、`hasUnsavedChanges`がfalseだった

**詳細な原因**:

1. **PC版の問題**: `handleConfirmClose`で`onClose()`を呼んでいなかった
   - `use-unsaved-changes-guard`フックが保留中の選択を実行することを期待していた
   - しかし、エディターの閉じるボタンを直接押した場合、保留中の選択がないため何も起こらない

2. **モバイル版の問題**: `useEffect`の依存配列に`hasUnsavedChanges`（state）が含まれていた
   - 依存配列に`hasUnsavedChanges`があると、値が変わるたびにイベントリスナーが再登録される
   - イベントハンドラー内で`hasUnsavedChanges`（state）を参照すると、クロージャーの問題で古い値を参照してしまう
   - 正しくは`memoEditorHasUnsavedChangesRef.current`から最新の値を読み取る必要がある

### 修正内容

#### 1. PC版の修正

**ファイル**: `apps/web/components/features/memo/memo-editor.tsx:1174-1187`

```typescript
// 確認モーダルで「閉じる」を選択
const handleConfirmClose = useCallback(() => {
  console.log("[MemoEditor] handleConfirmClose called");
  setIsCloseConfirmModalOpen(false);
  // 破棄が選択されたことを通知（保留中の選択を実行するため）
  dispatchDiscardEvent("memo");
  // 保留中の選択がない場合（戻るボタンの場合）はonCloseを呼ぶ
  // 少し遅延させてdispatchDiscardEventが処理されるのを待つ
  console.log("[MemoEditor] Calling onClose after 50ms delay");
  setTimeout(() => {
    console.log("[MemoEditor] Executing onClose");
    onClose();
  }, 50);
}, [onClose]);
```

#### 2. モバイル版の修正

**ファイル**: `apps/web/components/features/memo/memo-editor.tsx:1122-1171`

```typescript
// モバイルフッター戻るボタンイベント（Context経由）
useEffect(() => {
  const handleMobileBackRequested = () => {
    if (teamMode && teamDetailContext) {
      // Contextから最新の状態を読み取る
      const currentHasUnsavedChanges =
        teamDetailContext.memoEditorHasUnsavedChangesRef.current;
      const showModal = teamDetailContext.memoEditorShowConfirmModalRef.current;

      if (currentHasUnsavedChanges && showModal) {
        showModal();
      } else {
        onClose();
      }
    } else {
      // 個人ページの場合もrefから読み取る（stateではなく）
      const currentHasUnsavedChanges =
        memoEditorHasUnsavedChangesRef?.current ?? false;
      if (currentHasUnsavedChanges) {
        setIsCloseConfirmModalOpen(true);
      } else {
        onClose();
      }
    }
  };

  window.addEventListener(
    "memo-editor-mobile-back-requested",
    handleMobileBackRequested,
  );
  return () => {
    window.removeEventListener(
      "memo-editor-mobile-back-requested",
      handleMobileBackRequested,
    );
  };
}, [teamMode, teamDetailContext, memoEditorHasUnsavedChangesRef, onClose]);
// 重要: hasUnsavedChanges（state）は依存配列から削除
```

### テスト結果

- [x] PC版: 個人のメモ一覧でエディター閉じるボタン → モーダル表示 → 閉じるボタン → エディターが閉じる ✅
- [x] モバイル版: 個人のメモ一覧でフッター戻るボタン → モーダル表示 ✅

### 影響範囲

#### 修正ファイル

- `apps/web/components/features/memo/memo-editor.tsx`
  - `handleConfirmClose`: `onClose()`を50ms遅延で呼ぶように修正
  - モバイル戻るボタンイベントリスナー: `memoEditorHasUnsavedChangesRef.current`から値を読み取るように修正
  - useEffectの依存配列: `hasUnsavedChanges`を削除、`memoEditorHasUnsavedChangesRef`を追加

- `apps/web/components/screens/memo-screen.tsx`
  - refをMemoEditorに渡す際のデバッグログ追加（テスト後削除予定）

- `apps/web/components/layout/sidebar.tsx`
  - モバイル戻るボタンのデバッグログ追加（テスト後削除予定）

### 学んだこと

1. **useEffectの依存配列とクロージャー**
   - stateを依存配列に入れると、イベントリスナーが再登録される
   - イベントハンドラー内でstateを参照すると、古い値を参照する可能性がある
   - refを使えば常に最新の値を参照できる

2. **未保存変更ガードの2つのパターン**
   - パターン1: 別のアイテムを選択した場合 → `use-unsaved-changes-guard`が処理
   - パターン2: 閉じるボタンを押した場合 → エディター自身が`onClose()`を呼ぶ必要がある

---

## 目的

個人・チーム両方のメモ一覧・タスク一覧で、PC版では未保存の変更がある時に閉じようとすると確認モーダルが出るのに、**モバイル版では出ない**問題を調査・修正する。

## 現状の理解

### 既存の仕組み（正常に動作しているはず）

1. **MemoEditor / TaskEditor**
   - `memo-editor-mobile-back-requested` / `task-editor-mobile-back-requested` イベントをリッスン
   - イベント受信時に未保存変更をチェック
   - 未保存変更があれば確認モーダル表示
   - なければ `onClose()` を実行

2. **Sidebar (個人モード)**
   - `ItemEditorFooter` の「戻る」ボタンで `memo-editor-mobile-back-requested` を発火
   - イベント発火場所: `apps/web/components/layout/sidebar.tsx:242`

3. **確認モーダルの実装**
   - MemoEditor: `apps/web/components/features/memo/memo-editor.tsx:1118-1152`
   - 個人モード: `hasUnsavedChanges` をチェック → `setIsCloseConfirmModalOpen(true)`
   - チームモード: `teamDetailContext.memoEditorHasUnsavedChangesRef` をチェック

## 問題の可能性

### 仮説1: イベントが発火していない

- Sidebarが表示されていない
- イベント名が間違っている
- タイミングの問題

### 仮説2: イベントは発火しているが、hasUnsavedChangesがfalse ✅ **これが原因だった**

- 未保存状態の検出が動作していない
- refの更新が反映されていない

### 仮説3: モーダルが表示されているが見えない

- z-indexの問題
- モーダルが画面外に表示されている

### 仮説4: 特定の画面・状態でのみ問題が発生

- メモ一覧 vs タスク一覧
- 新規作成 vs 編集
- 個人モード vs チームモード
- ボード詳細内 vs 通常画面

## 調査手順

### 1. 問題の再現条件を特定

- [x] 個人のメモ一覧でメモ編集時
- [ ] 個人のタスク一覧でタスク編集時
- [ ] チームのメモ一覧でメモ編集時
- [ ] チームのタスク一覧でタスク編集時
- [ ] ボード詳細内でのメモ/タスク編集時
- [ ] 新規作成時 vs 既存アイテム編集時

### 2. デバッグログ追加

- [x] Sidebar の onBack にログ追加（イベント発火確認）
- [x] MemoEditor / TaskEditor のイベントリスナーにログ追加（イベント受信確認）
- [x] hasUnsavedChanges の値をログ出力
- [x] モーダル表示フラグをログ出力

### 3. 問題箇所の特定

- [x] イベントが発火しているか確認
- [x] イベントが受信されているか確認
- [x] hasUnsavedChanges が正しく設定されているか確認 → **refから読み取っていなかった**
- [x] モーダルが実際に表示されているか確認（DOM確認）

### 4. 修正案の検討

問題箇所に応じて以下のいずれかを実施：

**A. イベントが発火していない場合**

- Sidebar の条件分岐を修正
- イベント名を修正
- Sidebar の表示条件を修正

**B. hasUnsavedChanges が false の場合** ✅ **これを実施**

- ref の更新タイミングを修正
- エディターの変更検出ロジックを修正

**C. モーダルが表示されない場合**

- モーダルコンポーネントの z-index を修正
- モーダルの表示条件を修正

## 影響範囲

### 調査対象ファイル

- `apps/web/components/layout/sidebar.tsx` - モバイルフッター「戻る」ボタン
- `apps/web/components/features/memo/memo-editor.tsx` - メモエディターのイベントリスナー
- `apps/web/components/features/task/task-editor.tsx` - タスクエディターのイベントリスナー
- `apps/web/components/screens/memo-screen.tsx` - メモ画面の状態管理
- `apps/web/components/screens/task-screen.tsx` - タスク画面の状態管理

### テスト対象

- 個人のメモ一覧（モバイル表示）
- 個人のタスク一覧（モバイル表示）
- チームのメモ一覧（モバイル表示）
- チームのタスク一覧（モバイル表示）
- ボード詳細内のメモ/タスク編集（モバイル表示）

## 優先度

**高** - モバイル版での重要なUX問題

## 備考

- PC版では正常に動作しているため、PC版の実装を参考にする
- チーム側と個人側で同じ問題があるため、共通の原因の可能性が高い
- まずはデバッグログで問題箇所を特定してから修正を行う
