# システム安定化総合計画

## 🎯 目的

繰り返し発生する不具合を根本から解決し、システム全体の安定性を向上させる

## 📊 現状の問題点まとめ

### 🔴 高優先度（何度も再発している問題）

#### 1. ボード紐づけデータの不整合

- **症状**: ボード紐づけが表示されない、チーム/個人で動作が異なる
- **原因**: データ取得が分散、チーム/個人判定ロジックが複数箇所に散在
- **影響**: メモ/タスクエディター全般
- **対応**: ✅ 専用計画書作成済み（`ボード紐づけデータ取得一本化計画.md`）

#### 2. originalId型の不統一

- **症状**: string/number混在による型エラー、比較ミス
- **原因**: DBはTEXT型、コードではnumber型も混在、変換処理が散在
- **影響**: 全てのアイテム操作（メモ、タスク、ボード紐づけ）
- **対応**: 🔜 計画策定必要

#### 3. チーム/個人モード判定の分散

- **症状**: 片方のモードでのみ動作しない
- **原因**: 判定ロジックが複数箇所（API、フロント、URL判定）
- **影響**: 全てのチーム機能
- **対応**: 🔜 計画策定必要

---

### 🟡 中優先度（潜在的な問題）

#### 4. preloadedDataとAPI取得データの使い分け

- **症状**: どちらを使うべきか不明確、パフォーマンス問題
- **原因**: 両方の取得方法が混在、使い分けルールが不明確
- **影響**: 全画面のデータ表示
- **対応**: ボード紐づけ一本化で一部解決、他も同様の方針検討

#### 5. React Query設定の最適化

- **症状**: キャッシュの有効期限が適切でない、不要な再取得
- **原因**: `staleTime: 0`や`keepPreviousData`の不統一使用
- **影響**: API呼び出し回数、パフォーマンス
- **対応**: 🔜 設定レビュー必要

---

## 📋 改善計画

### 計画1: ボード紐づけデータ取得一本化 ✅

**詳細**: `ボード紐づけデータ取得一本化計画.md` 参照

**概要**:

- 親コンポーネントでデータ取得
- 子コンポーネントはpropsのみ使用
- チーム/個人判定を親で一元化

**期待効果**:

- ✅ データフローの明確化
- ✅ デバッグ容易性向上
- ✅ 同様バグの再発防止

---

### 計画2: originalId型システム統一

#### 🎯 目的

originalIdの型を完全に統一し、型エラーと比較ミスを根絶

#### 📍 現状

**DB定義**:

```sql
-- すべてTEXT型
original_id TEXT NOT NULL
```

**コード内**:

```typescript
// 混在している
task.originalId; // string | undefined
task.id.toString(); // string
parseInt(itemId); // number
memo?.originalId || memo?.id?.toString(); // 変換処理が散在
```

#### 🔧 改善内容

**1. 型定義の統一**

```typescript
// apps/web/src/types/common.ts

/**
 * originalId型定義
 * DBではTEXT型として保存されているIDを表す
 */
export type OriginalId = string;

/**
 * ID変換ユーティリティ
 */
export const OriginalIdUtils = {
  /**
   * number | string | undefined を OriginalId に変換
   */
  from(id: number | string | undefined): OriginalId | undefined {
    if (id === undefined || id === 0 || id === "0") return undefined;
    return id.toString();
  },

  /**
   * OriginalId を number に変換（必要な場合のみ）
   */
  toNumber(originalId: OriginalId | undefined): number | undefined {
    if (!originalId) return undefined;
    const num = parseInt(originalId, 10);
    return isNaN(num) ? undefined : num;
  },

  /**
   * アイテムからoriginalIdを取得
   */
  fromItem(
    item: { id?: number; originalId?: string } | undefined,
  ): OriginalId | undefined {
    if (!item) return undefined;
    return item.originalId || this.from(item.id);
  },
};
```

**2. 既存コードの置き換え**

```typescript
// Before
const originalId = task?.originalId || task?.id?.toString();

// After
const originalId = OriginalIdUtils.fromItem(task);
```

**3. 影響範囲**

- MemoEditor, TaskEditor
- useItemBoards, useTeamItemBoards
- API呼び出し全般
- useSimpleItemSave

#### ✅ テスト項目

- [ ] メモ/タスクのoriginalId取得が正しい
- [ ] ボード紐づけでoriginalId比較が正しい
- [ ] API呼び出し時のoriginalIdが正しい
- [ ] 型エラーが発生しない

---

### 計画3: チーム/個人モード判定の一元化

#### 🎯 目的

チーム/個人の判定ロジックを一箇所に集約し、判定ミスを防止

#### 📍 現状の問題

**判定ロジックが3箇所に分散**:

```typescript
// 1. API側（サーバー）
const isTeamItem = await db.select(...).from(teamMemos)...

// 2. フロント側（propsチェック）
if (teamMode) { ... }

// 3. URLパス判定
window.location.pathname.includes("/team/")
```

→ **どれを信用すべきか不明確、判定漏れが発生**

#### 🔧 改善内容

**1. Contextで一元管理**

```typescript
// apps/web/src/contexts/team-context.tsx

interface TeamContextValue {
  isTeamMode: boolean;
  teamId: number | null;
  teamSlug: string | null;
}

export const TeamContext = createContext<TeamContextValue>({
  isTeamMode: false,
  teamId: null,
  teamSlug: null,
});

export function TeamProvider({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();

  // URLから判定（単一の信頼できるソース）
  const teamMatch = pathname.match(/^\/team\/([^\/]+)/);
  const isTeamMode = !!teamMatch;
  const teamSlug = teamMatch?.[1] || null;

  // teamSlugからteamIdを取得（APIまたはキャッシュ）
  const { data: team } = useTeamBySlug(teamSlug);
  const teamId = team?.id || null;

  return (
    <TeamContext.Provider value={{ isTeamMode, teamId, teamSlug }}>
      {children}
    </TeamContext.Provider>
  );
}

// カスタムフック
export function useTeamContext() {
  return useContext(TeamContext);
}
```

**2. 使用例**

```typescript
// Before（複数の判定方法が混在）
function MemoEditor({ teamMode, teamId, ... }) {
  if (teamMode) { ... }
}

// After（統一されたContext使用）
function MemoEditor({ ... }) {
  const { isTeamMode, teamId } = useTeamContext();
  if (isTeamMode) { ... }
}
```

**3. API側の対応**

```typescript
// サーバー側は引き続きoriginalIdベースで判定
// フロント側で統一されたteamIdを渡す
const response = await fetch(
  `${API_BASE_URL}/items/${itemType}/${originalId}/boards`,
  {
    headers: {
      "X-Team-Id": teamId?.toString() || "", // ヘッダーで渡す
    },
  },
);
```

#### ✅ テスト項目

- [ ] 個人モードで正しく動作
- [ ] チームモードで正しく動作
- [ ] URL変更時にコンテキストが更新される
- [ ] teamIdが正しく取得される

---

### 計画4: React Query設定の統一

#### 🎯 目的

キャッシュ戦略を統一し、不要な再取得を削減

#### 📍 現状の問題

**設定が場所によってバラバラ**:

```typescript
// ある場所
staleTime: 30 * 60 * 1000,  // 30分
keepPreviousData: true,

// 別の場所
staleTime: 0,  // キャッシュ無効
// keepPreviousDataなし
```

#### 🔧 改善内容

**1. 共通設定の定義**

```typescript
// apps/web/src/lib/query-config.ts

export const QUERY_DEFAULTS = {
  // アイテムデータ（メモ・タスク）
  items: {
    staleTime: 30 * 60 * 1000, // 30分
    cacheTime: 30 * 60 * 1000,
  },

  // ボード・タグなどマスタデータ
  master: {
    staleTime: 60 * 60 * 1000, // 1時間
    cacheTime: 60 * 60 * 1000,
  },

  // リアルタイム性が必要なデータ
  realtime: {
    staleTime: 0, // 常に最新取得
    cacheTime: 5 * 60 * 1000, // 5分だけキャッシュ
  },
};
```

**2. 使用例**

```typescript
// Before
staleTime: 0,

// After
...QUERY_DEFAULTS.items,  // または master, realtime
```

#### 📋 適用対象

- [ ] useItemBoards → `items`設定
- [ ] useTeamItemBoards → `items`設定
- [ ] useBoards → `master`設定
- [ ] useTags → `master`設定
- [ ] useComments → `realtime`設定

---

## 📅 実装スケジュール

### フェーズ1: 緊急対応（1-2日）✅ **完了**

- ✅ ボード紐づけデータ取得一本化（2025-10-09完了）
  - 個人タスクエディターのボード紐づけ表示修正
  - チームタスクエディターのボード紐づけ表示修正
  - データフローの明確化完了

### フェーズ2: 基盤整備（2-3日）🔄 **進行中**

- ✅ originalId型システム統一（2025-10-10完了）
  - ec38fd31: 初回実装（20ファイル）
  - f78b71f7: 残り修正（4ファイル）
  - 合計24ファイル、約45箇所を統一
- 🔄 チーム/個人モード判定の一元化（進行中）
  - 42279059: TeamContext実装
  - f87562af: use-board-operations移行（試験導入）
  - 残り: 28箇所のteamMode判定を移行予定

### フェーズ3: 最適化（1-2日）

- [ ] React Query設定の統一
- [ ] 不要なAPI呼び出し削減

### フェーズ4: 検証・安定化（1日）

- [ ] 全機能の動作確認
- [ ] パフォーマンス測定
- [ ] ドキュメント更新

---

## 📊 期待される効果

### 短期的効果

- ✅ ボード紐づけバグの解消
- ✅ 型エラーの削減
- ✅ チーム/個人切り替えの安定化

### 長期的効果

- 🎯 新機能追加時のバグ混入防止
- 🎯 デバッグ時間の大幅削減
- 🎯 コードの保守性向上
- 🎯 パフォーマンス改善

---

## 📝 各計画書へのリンク

1. ✅ [ボード紐づけデータ取得一本化計画](./ボード紐づけデータ取得一本化計画.md) - 作成済み
2. 🔜 originalId型システム統一計画 - この文書に含む
3. 🔜 チーム/個人モード判定一元化計画 - この文書に含む
4. 🔜 React Query設定統一計画 - この文書に含む

---

## 🔄 進捗管理

### ボード紐づけデータ取得一本化 ✅ **完了**（2025-10-09）

- [x] 計画策定
- [x] フェーズ1: 親コンポーネントでAPI取得追加
  - [x] MemoScreen実装
  - [x] TaskScreen実装
  - [x] BoardDetailScreen実装
  - [x] BoardDetailScreen-3panel（チーム用）実装
- [x] フェーズ2: エディター側での`preloadedItemBoards`優先使用
  - [x] MemoEditor
  - [x] TaskEditor
- [x] フェーズ3: BoardRightPanelへのprops受け渡し
  - [x] 個人モード
  - [x] チームモード
- [x] テスト・検証
- [x] **完了** - 個人・チーム両方で正しくボード紐づけ表示

### originalId型統一 ✅ **完了**（2025-10-10）

- [x] 計画策定
- [x] ユーティリティ実装（OriginalIdUtils作成）
- [x] 既存コード置き換え（24ファイル修正完了）
- [x] テスト・検証（TypeScriptエラー0件）
- [x] **完了** - すべての古いパターンをOriginalIdUtils.fromItem()に統一

### チーム/個人判定一元化 ✅ **完了**（2025-10-10）

- [x] 計画策定
- [x] TeamContext実装（team-context.tsx作成完了）
- [x] Screen層コンポーネント移行（7ファイル完了）
  - welcome-screen, search-screen, board-screen
  - memo-screen, task-screen
  - board-detail-screen, board-detail-screen-3panel
- [x] Editor層コンポーネント移行（2ファイル完了）
  - memo-editor, task-editor
- [x] Feature層コンポーネント移行（2ファイル完了）
  - board-memo-section, board-task-section
- [x] 親コンポーネント更新（14ファイル完了）
- [x] テスト・検証（TypeScriptエラー0件）
- [x] **完了** - すべての主要コンポーネントがTeamContextで統一

### React Query設定統一

- [x] 計画策定
- [ ] 共通設定定義
- [ ] 各フック更新
- [ ] テスト・検証
- [ ] 完了

---

## 📅 作成日

2025-10-08

## 📝 ステータス

**フェーズ2完了 - 型統一とコンテキスト統一が完了**（最終更新: 2025-10-10）

### 完了済み

- ✅ フェーズ1: 緊急対応 - ボード紐づけデータ取得一本化（2025-10-09完了）
- ✅ フェーズ2-1: originalId型システム統一（2025-10-10完了）
- ✅ フェーズ2-2: チーム/個人判定一元化（2025-10-10完了）
  - 修正ファイル: 25ファイル（Screen 7 + Editor 2 + Feature 2 + 親 14）
  - TypeScriptエラー: 0件

### 次のステップ

- 🎯 フェーズ3: React Query設定統一
- 🎯 フェーズ4: 全機能の動作確認・パフォーマンス測定
- 🎯 フェーズ5: パフォーマンス最適化・負荷テスト
