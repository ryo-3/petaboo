# リファクタリングチェックルール

コミット前に以下の項目をチェックしてください。

## 🔴 エラー（コミット中断を推奨）

### 1. 危険な型キャスト

- `as unknown as` の使用
- **理由**: 型安全性を破壊する
- **推奨**: Zodスキーマでバリデーション

### 2. title属性の直接使用

- HTMLタグの `title=` 属性
- **理由**: UIコンポーネントの一貫性
- **推奨**: Tooltipコンポーネントを使用

### 3. 共通型の未使用

- `OriginalId` 型を使わず `string` 直書き
- **理由**: 型安全性と一貫性
- **推奨**: `apps/web/src/types/common.ts` の共通型を使用

## 🟡 警告（確認推奨、コミットは可）

### 4. any型の使用

- `: any` 型の使用
- **理由**: 型安全性の低下
- **推奨**: 具体的な型定義

### 5. 型エラー抑制

- `@ts-ignore` / `@ts-expect-error` コメント
- **理由**: 根本的な問題を隠蔽
- **推奨**: 型エラーの根本修正

### 6. コード重複

- 同じ関数名が複数ファイルに存在
- 同じロジックの繰り返し
- **理由**: 保守性の低下
- **推奨**: 共通化（2回以上使うなら即共通化）

### 7. console.log の残留

- `console.log` / `console.warn` / `console.error`
- **理由**: デバッグコードの残留
- **推奨**: 本番環境では削除

### 8. 長い関数

- 100行以上の関数
- **理由**: 可読性・保守性の低下
- **推奨**: 小さな関数に分割

## 🔵 既存動作への影響チェック（重要）

### 9. 影響範囲の特定

**チェック項目:**

- 変更した関数・フックはどこで使われているか
- 影響を受ける可能性のある機能は何か
- 個人モードとチームモード両方で動作するか

**確認方法:**

```bash
# 使用箇所を検索
grep -r "use-simple-item-save" apps/web/
grep -r "memo-editor" apps/web/
```

### 10. 既存動作の破壊チェック

**チェック項目:**

- 条件分岐の変更で既存ケースが壊れていないか
- デフォルト値の変更による影響はないか
- 型の変更で呼び出し側に影響はないか
- 必須パラメータの追加で既存コードが壊れないか

**例:**

```typescript
// 🔴 危険: 既存の動作を変更
if (isNewItem) return !!strippedTitle || hasAttachmentChanges;

// ✅ 安全: itemTypeで分岐して既存動作を維持
if (isNewItem) {
  if (itemType === "memo") {
    return !!strippedTitle || hasAttachmentChanges;
  }
  return !!strippedTitle; // タスクは既存通り
}
```

### 11. 副作用の確認

**チェック項目:**

- キャッシュ無効化の範囲は適切か（広すぎないか）
- API呼び出しの追加で負荷は増えないか
- イベントハンドラーの変更で無限ループは起きないか
- useEffectの依存配列の変更で再レンダリングループは起きないか

**確認すべき副作用:**

- React Queryのキャッシュ無効化
- ローカルストレージへの書き込み
- グローバルイベントの発火
- 親コンポーネントへのコールバック

### 12. エッジケースの考慮

**チェック項目:**

- 空データ（null/undefined/空配列）の場合の挙動は？
- エラー時の挙動は適切か（try-catchは必要か）
- 並行処理の競合は起きないか
- ネットワークエラー時の挙動は？

**例:**

```typescript
// チェック: teamId が undefined の場合の挙動
queryClient.invalidateQueries({
  queryKey: ["all-attachments", teamId, "memo"],
});
// → teamId が undefined でもキャッシュキーとして有効か？
```

### 13. 後方互換性

**チェック項目:**

- 既存のデータ構造との互換性は保たれているか
- 保存済みのデータは正しく読み込めるか
- APIレスポンスの形式変更はないか
- 古いバージョンのデータが壊れないか

## 📋 チェック方法

### 静的コードチェック

1. 変更ファイル（git diff --cached）を確認
2. コードパターンのルール（1-8）に違反していないかチェック
3. エラーがあればファイル名と行番号を報告
4. 警告は確認を促すが、コミットは許可

### 既存動作への影響チェック

5. 変更した関数・フックの使用箇所を grep で検索
6. 条件分岐・デフォルト値の変更がある場合、既存ケースへの影響を分析
7. キャッシュ無効化・API呼び出しの追加がある場合、副作用を確認
8. エッジケース（null/undefined/エラー時）の挙動を確認
9. 影響範囲を明示的にレポート

## 🎯 レポート形式

```
🔍 リファクタリングチェック結果

🔴 エラー（即修正推奨）
📍 apps/web/components/ui/button.tsx:42
  - `as unknown as` 使用検出
  💡 Zodスキーマでバリデーション推奨

🟡 警告
📍 apps/web/src/hooks/use-memo-list.ts:15
📍 apps/web/src/hooks/use-task-list.ts:18
  - 類似パターン検出（fetchList関数）
  💡 共通化候補: packages/shared/src/hooks/use-fetch-list.ts

🔵 既存動作への影響（確認推奨）
📍 apps/web/src/hooks/use-simple-item-save.ts:823
  - canSave条件の変更検出
  影響範囲: メモ・タスクの保存動作
  確認項目:
    ✅ メモ: タイトルなし + 画像のみで保存可能（新仕様）
    ✅ タスク: タイトル必須のまま（既存動作維持）
    ✅ 既存メモの更新時: タイトル必須（変更なし）
  副作用:
    - キャッシュ無効化追加により一覧表示が即座更新
    - パフォーマンスへの影響: 軽微（既存のinvalidateクエリと同等）

✅ 問題なし
- その他のファイル
```

## 💡 使用方法

コミット前に以下を実行：

```
リファクタリングチェックして
```

または

```
.claude/refactor-rules.md に従ってチェックして
```

**既存動作への影響も確認する場合:**

```
リファクタリングと既存動作への影響をチェックして
```

このコマンドで以下を実行：

1. 静的コードパターンチェック（ルール1-8）
2. 変更した関数の使用箇所検索
3. 影響範囲の分析
4. 副作用の確認
5. エッジケースの検証
