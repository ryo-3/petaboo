# 画像アップロード一元化 + 自動圧縮機能 実装Plan

> ⚠️ Codexに実装依頼する際は、以下を厳守すること：
> - **既存ファイルを丸ごと再生成させないこと** → Codexへの依頼は必ず **差分（patch形式）** で行う
> - **日本語コメント・文字列を扱う場合はUTF-8前提で依頼すること**
> - **Codexに git add / git commit を実行させないこと**
> - **完了した場合ファイルを`.claude/fixed-plans` に移動する**

---

## 目的

1. **画像アップロード処理の一元化** - 現在分散している処理を共通化
2. **自動圧縮機能の追加** - 5MB超の画像を自動圧縮してアップロード可能に

---

## 現状の課題

### 処理の分散
| 箇所 | サイズ制限 | 備考 |
|------|-----------|------|
| `use-attachment-manager.ts` | 画像5MB / ファイル20MB | メモ・タスク用 |
| `comment-section.tsx` | 10MB | 独自実装（重複コード） |

### 機能的課題
1. 5MB超の画像は「ファイルサイズが大きすぎます」エラーで弾かれる
2. スマホの高解像度写真などがそのままアップロードできない
3. バリデーションロジックが重複している

---

## 変更範囲

### 新規作成
1. `apps/web/src/utils/file-validator.ts` - ファイルバリデーション共通化
2. `apps/web/src/utils/image-compressor.ts` - 画像圧縮ユーティリティ

### 変更ファイル
1. `apps/web/src/hooks/use-attachment-manager.ts` - 共通バリデーション使用 + 圧縮処理
2. `apps/web/components/features/comments/comment-section.tsx` - 共通バリデーション使用 + 圧縮処理
3. `apps/web/package.json` - ライブラリ追加

---

## 実装手順

### Step 1: ライブラリ追加

```bash
cd apps/web && pnpm add browser-image-compression
```

**選定理由**:
- 軽量（gzip 10KB程度）
- Web Worker対応でUIブロックなし
- TypeScript対応
- 実績あり（週1M+ DL）

---

### Step 2: ファイルバリデーション共通化

**ファイル**: `apps/web/src/utils/file-validator.ts`

```typescript
/**
 * ファイルバリデーション共通ユーティリティ
 * メモ・タスク・コメントで共通使用
 */

// 許可されたMIMEタイプ
export const ALLOWED_FILE_TYPES = {
  images: [
    "image/jpeg",
    "image/jpg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/svg+xml",
  ],
  documents: [
    "application/pdf",
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.ms-powerpoint",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "text/plain",
    "text/csv",
  ],
} as const;

export const ALL_ALLOWED_TYPES = [
  ...ALLOWED_FILE_TYPES.images,
  ...ALLOWED_FILE_TYPES.documents,
];

// サイズ制限
export const FILE_SIZE_LIMITS = {
  image: 5 * 1024 * 1024,    // 5MB（圧縮前の上限、圧縮後はこれ以下になる）
  document: 20 * 1024 * 1024, // 20MB
} as const;

export const MAX_ATTACHMENTS_PER_ITEM = 10;

export interface FileValidationResult {
  valid: boolean;
  error?: string;
  needsCompression?: boolean; // 圧縮が必要かどうか
}

/**
 * ファイルが画像かどうかを判定
 */
export function isImageFile(file: File): boolean {
  return file.type.startsWith("image/");
}

/**
 * ファイルが圧縮可能な画像かどうかを判定
 * SVGとGIFは圧縮対象外
 */
export function isCompressibleImage(file: File): boolean {
  return (
    isImageFile(file) &&
    file.type !== "image/svg+xml" &&
    file.type !== "image/gif"
  );
}

/**
 * ファイルバリデーション
 * @param file - 検証するファイル
 * @param options - オプション（圧縮を考慮するかどうか）
 */
export function validateFile(
  file: File,
  options: { allowCompression?: boolean } = {}
): FileValidationResult {
  const { allowCompression = true } = options;

  // MIMEタイプチェック
  if (!ALL_ALLOWED_TYPES.includes(file.type as any)) {
    return {
      valid: false,
      error: `対応していないファイル形式です（${file.type}）`,
    };
  }

  // サイズチェック
  const isImage = isImageFile(file);
  const maxSize = isImage ? FILE_SIZE_LIMITS.image : FILE_SIZE_LIMITS.document;

  if (file.size > maxSize) {
    // 画像で圧縮可能な場合は圧縮を試みる
    if (allowCompression && isCompressibleImage(file)) {
      return {
        valid: true,
        needsCompression: true,
      };
    }

    const maxMB = maxSize / 1024 / 1024;
    return {
      valid: false,
      error: `ファイルサイズは${maxMB}MB以下にしてください`,
    };
  }

  return { valid: true, needsCompression: false };
}
```

---

### Step 3: 圧縮ユーティリティ作成

**ファイル**: `apps/web/src/utils/image-compressor.ts`

```typescript
import imageCompression from "browser-image-compression";

export interface CompressionResult {
  file: File;
  wasCompressed: boolean;
  originalSize: number;
  compressedSize: number;
}

export interface CompressionOptions {
  maxSizeMB?: number;        // 目標サイズ（デフォルト: 5MB）
  maxWidthOrHeight?: number; // 最大幅/高さ（デフォルト: 2560px）
  quality?: number;          // 品質 0-1（デフォルト: 0.8）
}

const DEFAULT_OPTIONS: Required<CompressionOptions> = {
  maxSizeMB: 5,
  maxWidthOrHeight: 2560,
  quality: 0.8,
};

/**
 * 画像を圧縮する
 * - 画像以外のファイルはそのまま返す
 * - 既に目標サイズ以下の場合もそのまま返す
 */
export async function compressImage(
  file: File,
  options: CompressionOptions = {}
): Promise<CompressionResult> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const originalSize = file.size;

  // 画像以外はそのまま返す
  if (!file.type.startsWith("image/")) {
    return {
      file,
      wasCompressed: false,
      originalSize,
      compressedSize: originalSize,
    };
  }

  // SVGは圧縮不可（ベクター形式）
  if (file.type === "image/svg+xml") {
    return {
      file,
      wasCompressed: false,
      originalSize,
      compressedSize: originalSize,
    };
  }

  // 既に目標サイズ以下ならそのまま返す
  const maxSizeBytes = opts.maxSizeMB * 1024 * 1024;
  if (file.size <= maxSizeBytes) {
    return {
      file,
      wasCompressed: false,
      originalSize,
      compressedSize: originalSize,
    };
  }

  // 圧縮実行
  const compressedFile = await imageCompression(file, {
    maxSizeMB: opts.maxSizeMB,
    maxWidthOrHeight: opts.maxWidthOrHeight,
    initialQuality: opts.quality,
    useWebWorker: true,
    fileType: file.type as "image/jpeg" | "image/png" | "image/webp",
  });

  return {
    file: compressedFile,
    wasCompressed: true,
    originalSize,
    compressedSize: compressedFile.size,
  };
}

/**
 * 複数画像を並列圧縮
 */
export async function compressImages(
  files: File[],
  options: CompressionOptions = {}
): Promise<CompressionResult[]> {
  return Promise.all(files.map((file) => compressImage(file, options)));
}

/**
 * 圧縮結果のサマリーを取得
 */
export function getCompressionSummary(results: CompressionResult[]): {
  totalOriginal: number;
  totalCompressed: number;
  compressedCount: number;
  savedBytes: number;
  savedPercent: number;
} {
  const totalOriginal = results.reduce((sum, r) => sum + r.originalSize, 0);
  const totalCompressed = results.reduce((sum, r) => sum + r.compressedSize, 0);
  const compressedCount = results.filter((r) => r.wasCompressed).length;
  const savedBytes = totalOriginal - totalCompressed;
  const savedPercent = totalOriginal > 0 ? (savedBytes / totalOriginal) * 100 : 0;

  return {
    totalOriginal,
    totalCompressed,
    compressedCount,
    savedBytes,
    savedPercent,
  };
}
```

---

### Step 3: use-attachment-manager.ts への組み込み

**変更箇所**: `handleFileSelect` と `handleFilesSelect` 内

```typescript
// インポート追加
import { compressImage, compressImages } from "@/src/utils/image-compressor";

// handleFileSelect内の変更（バリデーション前に圧縮）
const handleFileSelect = useCallback(
  async (file: File) => {
    // 画像の場合は圧縮を試みる
    let processedFile = file;
    if (file.type.startsWith("image/") && file.type !== "image/svg+xml") {
      try {
        const result = await compressImage(file, { maxSizeMB: 5 });
        processedFile = result.file;
        if (result.wasCompressed) {
          const savedMB = ((result.originalSize - result.compressedSize) / 1024 / 1024).toFixed(1);
          showToast(`画像を圧縮しました（${savedMB}MB削減）`, "info", 3000);
        }
      } catch (error) {
        console.error("画像圧縮エラー:", error);
        // 圧縮失敗時は元ファイルでバリデーション
      }
    }

    // バリデーション（圧縮後のファイルで）
    if (!validateImageFile(processedFile)) {
      return;
    }
    // ... 以降は既存ロジック
  },
  [validateImageFile, showToast]
);
```

**注意点**:
- `handleFileSelect` を `async` に変更
- 呼び出し元で `await` が必要になる場合あり
- ペースト処理（`handlePaste`）も同様に対応

---

### Step 4: comment-section.tsx への組み込み

同様の変更を適用。独自の `validateImageFile` の前に圧縮処理を追加。

---

### Step 5: UXの考慮

1. **圧縮中インジケーター**（任意）
   - 大きな画像の圧縮は1-2秒かかる場合あり
   - 必要に応じてローディング表示

2. **フィードバック**
   - 圧縮した場合: 「画像を圧縮しました（X.X MB削減）」
   - 圧縮してもダメな場合: 既存エラーメッセージ

3. **エッジケース**
   - GIFアニメ: 圧縮で静止画になる可能性 → 警告 or 除外
   - 圧縮しても5MB超: エラー表示

---

## 影響範囲・懸念点

1. **GIFアニメーション**
   - 圧縮するとアニメーションが失われる
   - 対策: GIFは圧縮対象外にする or 警告表示

2. **圧縮品質**
   - quality: 0.8 で見た目はほぼ変わらない
   - 必要に応じてユーザー設定可能にする（将来拡張）

3. **パフォーマンス**
   - Web Worker使用でUIブロックなし
   - 複数画像の並列処理対応済み

---

## Codex用 ToDoリスト

### Phase 1: 共通ユーティリティ作成
- [ ] `cd apps/web && pnpm add browser-image-compression` を実行
- [ ] `apps/web/src/utils/file-validator.ts` を新規作成（バリデーション共通化）
- [ ] `apps/web/src/utils/image-compressor.ts` を新規作成（圧縮処理）

### Phase 2: use-attachment-manager.ts のリファクタリング
- [ ] 共通バリデーション（`validateFile`）をインポート
- [ ] 独自の `validateImageFile` を削除し、共通関数に置き換え
- [ ] 圧縮処理を `handleFileSelect` / `handleFilesSelect` に組み込み
- [ ] `handlePaste` 内の処理も対応

### Phase 3: comment-section.tsx のリファクタリング
- [ ] 共通バリデーション（`validateFile`）をインポート
- [ ] 独自の `validateImageFile` を削除し、共通関数に置き換え
- [ ] 圧縮処理を `handleFileSelect` に組み込み
- [ ] `handlePaste` 内の処理も対応

### Phase 4: 動作確認
- [ ] メモ/タスクで10MB程度の画像をアップロードして圧縮されることを確認
- [ ] コメントで10MB程度の画像をアップロードして圧縮されることを確認
- [ ] GIF/SVGが圧縮されずにそのまま処理されることを確認
- [ ] PDF等のドキュメントが影響を受けないことを確認

---

## 備考

- `browser-image-compression` は圧縮後も元のファイル名を保持
- WebP出力も可能だが、互換性のため元の形式を維持
- 将来的に圧縮設定をユーザーが変更できるようにする拡張も可能
