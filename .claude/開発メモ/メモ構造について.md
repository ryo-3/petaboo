# メモの削除・復元構造の詳細分析

## 🎯 シンプル化後のメモ構造（現在の実装）

### 1. 削除済みメモの復元処理

**場所**: `memo-screen.tsx` の `onRestore` コールバック

```typescript
onRestore={async () => {
  if (selectedDeletedMemo && deletedMemos) {
    // ① 復元前に次選択対象を事前計算
    const currentIndex = deletedMemos.findIndex(
      (memo) => memo.originalId === selectedDeletedMemo.originalId
    );
    const remainingMemos = deletedMemos.filter(
      (memo) => memo.originalId !== selectedDeletedMemo.originalId
    );

    // ② 復元API実行（unifiedOperations使用）
    await restoreItem.mutateAsync(selectedDeletedMemo.originalId);

    // ③ 即座に次選択処理実行（タイマー不要）
    if (remainingMemos.length > 0) {
      const nextIndex = currentIndex >= remainingMemos.length
        ? remainingMemos.length - 1 : currentIndex;
      onSelectDeletedMemo(remainingMemos[nextIndex] || null);
    }
  }
}}
```

**ポイント**:

- ✅ 事前計算により非同期処理の影響を排除
- ✅ setTimeout や遅延処理を完全に削除
- ✅ 単一の責任原則（復元と次選択を明確に分離）
- ✅ unifiedOperations経由で統一的なAPI呼び出し

### 2. 削除済みメモの完全削除処理

**場所**: `memo-screen.tsx` の `onDelete` コールバック

```typescript
onDelete={async () => {
  if (selectedDeletedMemo && deletedMemos) {
    // ① 削除前に次選択対象を事前計算
    const currentIndex = deletedMemos.findIndex(
      (memo) => memo.originalId === selectedDeletedMemo.originalId
    );
    const remainingMemos = deletedMemos.filter(
      (memo) => memo.originalId !== selectedDeletedMemo.originalId
    );

    // ② 完全削除API実行
    await permanentDeleteMemo.mutateAsync(selectedDeletedMemo.id);

    // ③ 即座に次選択処理実行
    if (remainingMemos.length > 0) {
      const nextIndex = currentIndex >= remainingMemos.length
        ? remainingMemos.length - 1 : currentIndex;
      onSelectDeletedMemo(remainingMemos[nextIndex] || null);
    } else {
      setMemoScreenMode("list");
    }
  }
}}
```

**ポイント**:

- ✅ 復元と同じ事前計算パターン
- ✅ usePermanentDeleteMemo フック使用
- ✅ リストが空になった場合は自動的にリストビューへ

### 3. 通常メモの削除処理

**場所**: `memo-screen.tsx` の `handleMemoDeleteAndSelectNext`

```typescript
const handleMemoDeleteAndSelectNext = async (deletedMemo: Memo) => {
  if (!memos) return;

  // ① フィルター済みメモから次を選択
  const filteredMemos = memos.filter((m) => m.id !== deletedMemo.id);
  const currentIndex = memos.indexOf(deletedMemo);

  // ② 削除API実行（200ms遅延を削除済み）
  await deleteItem.mutateAsync(deletedMemo.id);

  // ③ 次のメモを選択
  let nextMemo = null;
  if (filteredMemos.length > 0) {
    if (currentIndex < filteredMemos.length) {
      nextMemo = filteredMemos[currentIndex];
    } else if (currentIndex > 0) {
      nextMemo = filteredMemos[currentIndex - 1];
    } else {
      nextMemo = filteredMemos[0];
    }
  }

  if (nextMemo) {
    onSelectMemo(nextMemo, true);
    setMemoScreenMode("view");
  } else {
    setMemoScreenMode("list");
    onClearSelection?.();
  }
};
```

**ポイント**:

- ✅ 200ms setTimeout を完全に削除
- ✅ 同期的な次選択処理
- ✅ unifiedOperations の deleteItem 使用

## 🔄 タスクの現在の構造（改善対象）

### 1. タスクの削除済み復元処理（複雑）

**場所**: `task-screen.tsx` line 310-317

```typescript
// 現在：useDeletedItemOperations経由の複雑な処理
const {
  selectNextDeletedItem: selectNextDeletedTask,
  handleRestoreAndSelectNext: handleDeletedTaskRestoreAndSelectNext,
} = useDeletedItemOperations({
  deletedItems: deletedTasks || null,
  onSelectDeletedItem: onSelectDeletedTask,
  setScreenMode: (mode: string) => setTaskScreenMode(mode as TaskScreenMode),
  editorSelector: "[data-task-editor]",
  restoreOptions: { isRestore: true, onSelectWithFromFlag: true },
});
```

**問題点**:

- ❌ 共通フックに依存した間接的な処理
- ❌ DOM セレクター依存
- ❌ 複雑なオプション設定

### 2. タスクの通常削除処理（タイマー付き）

**場所**: `task-screen.tsx` line 320-387

```typescript
const handleTaskDeleteAndSelectNext = (
  deletedTask: Task,
  preDeleteDisplayOrder?: number[],
) => {
  // ... 複雑な順序計算ロジック ...

  // 問題：100ms のsetTimeout がまだ残っている
  setTimeout(() => {
    document.querySelector("[data-task-editor]");
  }, 100);

  onSelectTask(nextTask, true);
  setTaskScreenMode("view");
};
```

**問題点**:

- ❌ DOM順序に依存した複雑な選択ロジック
- ❌ setTimeout による非同期処理
- ❌ 画面表示順序の事前計算が必要

## 📋 改善提案：タスクをメモと同じ構造に

### Step 1: 削除済みタスク復元をシンプル化

```typescript
// memo-screen.tsx の構造をそのまま適用
onRestore={async () => {
  if (selectedDeletedTask && deletedTasks) {
    // 事前計算
    const currentIndex = deletedTasks.findIndex(
      (task) => task.originalId === selectedDeletedTask.originalId
    );
    const remainingTasks = deletedTasks.filter(
      (task) => task.originalId !== selectedDeletedTask.originalId
    );

    // API実行
    await restoreItem.mutateAsync(selectedDeletedTask.originalId);

    // 即座に次選択
    if (remainingTasks.length > 0) {
      const nextIndex = currentIndex >= remainingTasks.length
        ? remainingTasks.length - 1 : currentIndex;
      onSelectDeletedTask(remainingTasks[nextIndex] || null);
    }
  }
}}
```

### Step 2: 通常タスク削除をシンプル化

```typescript
const handleTaskDeleteAndSelectNext = async (deletedTask: Task) => {
  if (!tasks) return;

  // 現在のタブでフィルター
  const filteredTasks = tasks.filter(
    (t) => t.status === activeTab && t.id !== deletedTask.id,
  );
  const currentTasks = tasks.filter((t) => t.status === activeTab);
  const currentIndex = currentTasks.indexOf(deletedTask);

  // API実行
  await deleteItem.mutateAsync(deletedTask.id);

  // メモと同じロジックで次選択
  let nextTask = null;
  if (filteredTasks.length > 0) {
    if (currentIndex < filteredTasks.length) {
      nextTask = filteredTasks[currentIndex];
    } else if (currentIndex > 0) {
      nextTask = filteredTasks[currentIndex - 1];
    } else {
      nextTask = filteredTasks[0];
    }
  }

  if (nextTask) {
    onSelectTask(nextTask, true);
    setTaskScreenMode("view");
  } else {
    setTaskScreenMode("list");
    onClearSelection?.();
  }
};
```

### Step 3: 削除済みタスク完全削除を追加

```typescript
// 新規追加：usePermanentDeleteTaskフック作成が必要
onDelete={async () => {
  if (selectedDeletedTask && deletedTasks) {
    // 事前計算
    const currentIndex = deletedTasks.findIndex(
      (task) => task.originalId === selectedDeletedTask.originalId
    );
    const remainingTasks = deletedTasks.filter(
      (task) => task.originalId !== selectedDeletedTask.originalId
    );

    // 完全削除API実行
    await permanentDeleteTask.mutateAsync(selectedDeletedTask.id);

    // 次選択
    if (remainingTasks.length > 0) {
      const nextIndex = currentIndex >= remainingTasks.length
        ? remainingTasks.length - 1 : currentIndex;
      onSelectDeletedTask(remainingTasks[nextIndex] || null);
    } else {
      setTaskScreenMode("list");
    }
  }
}}
```

## 🎯 統一化のメリット

1. **コード重複の削除**: メモとタスクで同じロジックを共有
2. **保守性向上**: 一箇所を修正すれば両方に反映
3. **バグ減少**: シンプルな構造で予期しない動作を防止
4. **パフォーマンス向上**: 不要なDOM操作とタイマーを削除
5. **理解しやすさ**: 直線的な処理フローで可読性向上

## 📌 実装優先順位

1. **タスクの復元処理** ← 現在作業中
2. **タスクの通常削除処理**
3. **タスクの削除済み完全削除処理**
4. **共通フック作成**（将来的に検討）
