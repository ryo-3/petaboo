# ボードデータ取得現状分析

## 1. データ取得の全体像

### 1.1 ボード一覧データの取得

**取得箇所（9ファイル）:**

1. **Screen層（6ファイル）**
   - `board-detail-screen.tsx` - ボード詳細画面
   - `board-detail-screen-3panel.tsx` - ボード詳細画面（3パネル版）
   - `task-screen.tsx` - タスク一覧画面
   - `memo-screen.tsx` - メモ一覧画面
   - `board-screen.tsx` - ボード一覧画面

2. **Component層（3ファイル）**
   - `board-list.tsx` - ボード一覧コンポーネント
   - `board-selector.tsx` - ボードセレクター

3. **Hook層（2ファイル）**
   - `use-boards.ts` - 個人ボード取得フック（定義）
   - `use-team-boards.ts` - チームボード取得フック（定義）

**使用されるAPI:**

- `GET /boards` - 個人ボード一覧
- `GET /teams/{teamId}/boards` - チームボード一覧

### 1.2 ボード紐づけデータの取得

**取得箇所（12ファイル）:**

1. **Screen層で取得してpropsで渡す（4パターン）**

   **パターン1: ボード詳細画面 → BoardRightPanel → Editor**

   ```
   board-detail-screen.tsx (useItemBoards/useTeamItemBoards呼び出し)
     ↓ preloadedBoardItems（配列）を渡す
   board-right-panel.tsx
     ↓ preloadedBoardItems（配列）を渡す
   memo-editor.tsx / task-editor.tsx（propsで受け取るのみ）
   ```

   **パターン2: メモ一覧画面 → Editor**

   ```
   memo-screen.tsx（取得なし）
     ↓ preloadedBoards（全ボード一覧）のみ渡す
   memo-editor.tsx（useItemBoards/useTeamItemBoards呼び出し）
   ```

   **パターン3: タスク一覧画面 → Editor**

   ```
   task-screen.tsx（取得なし）
     ↓ preloadedBoards（全ボード一覧）のみ渡す
   task-editor.tsx（useItemBoards/useTeamItemBoards呼び出し）
   ```

   **パターン4: 表示コンポーネント**

   ```
   item-display.tsx（preloadedBoardsを受け取る）
   task-status-display.tsx（preloadedBoardsを受け取る）
   memo-status-display.tsx（preloadedBoardsを受け取る）
   ```

2. **Editorで直接取得（2ファイル）**
   - `memo-editor.tsx` - useItemBoards/useTeamItemBoards呼び出し
   - `task-editor.tsx` - useItemBoards/useTeamItemBoards呼び出し

3. **その他**
   - `item-filter-wrapper.tsx` - useItemBoards呼び出し（フィルター用）

**使用されるAPI:**

- `GET /boards/items/{itemType}/{itemId}/boards` - 個人アイテムのボード紐づけ
- `GET /teams/{teamId}/items/{itemType}/{itemId}/boards` - チームアイテムのボード紐づけ

## 2. データフロー図

```
【個人ボード詳細画面】
board-detail-screen.tsx
├─ useBoards("normal")           → boards配列取得
├─ useItemBoards(itemType, itemId) → itemBoards配列取得（API呼び出し）
└─ preloadedBoardItems として渡す
   ↓
   board-right-panel.tsx
   └─ そのまま preloadedBoardItems として渡す
      ↓
      memo-editor.tsx / task-editor.tsx
      ├─ propsでpreloadedBoardItemsを受け取る
      ├─ useItemBoards(itemType, itemId) も呼び出す（API呼び出し重複）
      └─ itemBoardsを計算（preloadedBoardItems + API結果 + initialBoardId）

【チームボード詳細画面】
board-detail-screen.tsx
├─ useTeamBoards(teamId, "normal") → boards配列取得
├─ useTeamItemBoards(teamId, itemType, itemId) → itemBoards配列取得（API呼び出し）
└─ preloadedBoardItems として渡す
   ↓
   board-right-panel.tsx
   └─ そのまま preloadedBoardItems として渡す
      ↓
      memo-editor.tsx / task-editor.tsx
      ├─ propsでpreloadedBoardItemsを受け取る
      ├─ useTeamItemBoards(teamId, itemType, itemId) も呼び出す（API呼び出し重複）
      └─ itemBoardsを計算（preloadedBoardItems + API結果）

【個人メモ一覧画面】
memo-screen.tsx
├─ useBoards("normal")           → boards配列取得
└─ preloadedBoards として渡す（紐づけデータなし）
   ↓
   memo-editor.tsx
   ├─ propsでpreloadedBoardsを受け取る
   ├─ useItemBoards(itemType, itemId) 呼び出し（API呼び出し）
   └─ itemBoardsを計算（API結果 + initialBoardId）

【個人タスク一覧画面】
task-screen.tsx
├─ useBoards("normal")           → boards配列取得
└─ preloadedBoards として渡す（紐づけデータなし）
   ↓
   task-editor.tsx
   ├─ propsでpreloadedBoardsを受け取る
   ├─ useItemBoards(itemType, itemId) 呼び出し（API呼び出し）
   └─ itemBoardsを計算（API結果 + initialBoardId）
```

## 3. 問題点の特定

### 3.1 データ取得の重複

**❌ 問題1: 同じデータを親と子で2回取得**

ボード詳細画面では：

1. `board-detail-screen.tsx` で `useItemBoards` を呼び出し
2. その結果を `preloadedBoardItems` として渡す
3. `memo-editor.tsx` / `task-editor.tsx` でも `useItemBoards` を呼び出す
4. **結果: 同じAPIを2回呼び出している**

```typescript
// board-detail-screen.tsx（親）
const { data: itemBoards = [] } = useItemBoards(itemType, itemId);
const preloadedBoardItems = itemBoards;

// memo-editor.tsx（子）
const { data: personalItemBoards = [] } = useItemBoards("memo", itemId);
// ↑ 同じデータを再取得している
```

### 3.2 データソースの不整合

**❌ 問題2: itemBoards計算が複数箇所に分散**

現在のitemBoards計算ロジック：

- `memo-editor.tsx`: preloadedBoardItems + API結果 + initialBoardId
- `task-editor.tsx`: preloadedBoardItems + API結果 + initialBoardId
- 計算ロジックが重複し、メンテナンスしづらい

**❌ 問題3: staleTime設定の不整合**

```typescript
// use-boards.ts
export function useItemBoards() {
  return useQuery({
    staleTime: 0, // キャッシュ無効化
  });
}

// しかし親で取得したデータは staleTime: 30分
// → 親と子で異なるキャッシュ戦略
```

### 3.3 条件分岐の複雑化

**❌ 問題4: チーム/個人の判定が各所に分散**

```typescript
// memo-editor.tsx
const itemBoards = useMemo(() => {
  if (!task || task.id === undefined || task.id === 0) {
    // 新規作成時の処理
  }

  if (teamMode) {
    return teamItemBoards; // チーム用
  }

  const boards = [...personalItemBoards]; // 個人用
  // ...
}, [dependencies]);
```

各エディターで同じ判定ロジックを重複実装している。

### 3.4 Props drilling

**❌ 問題5: 深いprops渡し**

```
board-detail-screen.tsx
  ↓ preloadedBoardItems
board-right-panel.tsx
  ↓ preloadedBoardItems
memo-editor.tsx / task-editor.tsx
```

3階層にわたってpropsを渡している。

## 4. データ取得パターンの分類

### パターンA: 親で取得 + 子で再取得（重複）

- **該当**: ボード詳細画面 → Editor
- **問題**: 同じAPIを2回呼び出し
- **原因**: 親のデータが不十分（initialBoardIdが含まれない）

### パターンB: 子のみで取得

- **該当**: メモ/タスク一覧画面 → Editor
- **問題**: 親でボード一覧は取得するが、紐づけは子で取得
- **原因**: 一覧画面では紐づけ情報が不要

### パターンC: 親で取得 + propsで渡す

- **該当**: Screen → StatusDisplay系
- **問題**: 特になし（正常パターン）

## 5. 理想的なデータフロー

### 5.1 親コンポーネントで一元取得

```
【ボード詳細画面】
board-detail-screen.tsx
├─ useBoards/useTeamBoards → boards配列
├─ useItemBoards/useTeamItemBoards → itemBoards配列
├─ initialBoardIdも考慮したitemBoards計算
└─ 完全なitemBoards配列をpropsで渡す
   ↓
   board-right-panel.tsx
   └─ そのまま渡す
      ↓
      memo-editor.tsx / task-editor.tsx
      └─ propsを使うのみ（API呼び出しなし）

【メモ/タスク一覧画面】
memo-screen.tsx / task-screen.tsx
├─ useBoards/useTeamBoards → boards配列
└─ 必要に応じてuseItemBoards呼び出し
   ↓
   memo-editor.tsx / task-editor.tsx
   └─ propsを使うのみ（API呼び出しなし）
```

### 5.2 期待される改善

1. **API呼び出し削減**: 同じデータの重複取得を排除
2. **ロジック統一**: itemBoards計算を親に集約
3. **キャッシュ戦略統一**: 親の設定のみで制御
4. **メンテナンス性向上**: 変更箇所が親のみ

## 6. 移行計画との対応

### フェーズ1で対応する項目

- [x] 問題1: データ取得の重複
- [x] 問題2: itemBoards計算の分散
- [x] 問題4: チーム/個人判定の分散

### フェーズ2で対応する項目

- [x] 問題3: staleTime設定の不整合（子のAPI呼び出し削除で解決）
- [x] 問題5: Props drilling（直接渡しで簡略化）

### フェーズ3で対応する項目

- [x] displayBoards計算の簡略化（親で完全なデータを渡すため、子での計算不要）

## 7. 影響範囲の整理

### 変更が必要なファイル（優先順）

**Phase 1: 親でデータ取得追加**

1. `board-detail-screen.tsx` - itemBoards計算ロジック追加
2. `board-detail-screen-3panel.tsx` - 同上
3. `memo-screen.tsx` - 必要に応じてuseItemBoards追加
4. `task-screen.tsx` - 必要に応じてuseItemBoards追加

**Phase 2: 子のAPI呼び出し削除** 5. `memo-editor.tsx` - useItemBoards削除6. `task-editor.tsx` - useItemBoards削除

**Phase 3: displayBoards簡略化** 7. `memo-editor.tsx` - displayBoards計算簡略化8. `task-editor.tsx` - displayBoards計算簡略化

### 変更不要なファイル

- `board-right-panel.tsx` - propsを渡すだけなので変更不要
- `item-display.tsx` - propsを受け取るだけなので変更不要
- `*-status-display.tsx` - propsを受け取るだけなので変更不要
- `use-boards.ts` / `use-team-boards.ts` - Hook定義は変更不要

## 8. テストポイント

### 8.1 個人モード

**ボード詳細画面:**

- [ ] メモエディターでボード一覧が正しく表示される
- [ ] タスクエディターでボード一覧が正しく表示される
- [ ] initialBoardIdが正しく含まれる
- [ ] 保存前に選択したボードが表示される

**メモ一覧画面:**

- [ ] メモエディターでボード一覧が正しく表示される
- [ ] 保存前に選択したボードが表示される

**タスク一覧画面:**

- [ ] タスクエディターでボード一覧が正しく表示される
- [ ] 保存前に選択したボードが表示される

### 8.2 チームモード

**ボード詳細画面:**

- [ ] メモエディターでボード一覧が正しく表示される
- [ ] タスクエディターでボード一覧が正しく表示される
- [ ] 保存前に選択したボードが表示される

**メモ一覧画面:**

- [ ] メモエディターでボード一覧が正しく表示される
- [ ] 保存前に選択したボードが表示される

**タスク一覧画面:**

- [ ] タスクエディターでボード一覧が正しく表示される
- [ ] 保存前に選択したボードが表示される

### 8.3 API呼び出し数の確認

- [ ] Network タブでAPI呼び出しが重複していないことを確認
- [ ] 各画面で必要最小限のAPI呼び出しのみ行われていることを確認

## 9. まとめ

### 現状の問題点

1. **データ取得の重複**: 親と子で同じAPIを2回呼び出し
2. **ロジックの分散**: itemBoards計算が各エディターに重複
3. **キャッシュ設定の不整合**: staleTime: 0 と 30分が混在
4. **条件分岐の複雑化**: チーム/個人判定が各所に分散
5. **Props drilling**: 3階層にわたるprops渡し

### 解決方針

- **親で一元取得**: すべてのデータ取得を親コンポーネントに集約
- **子は表示のみ**: エディターはpropsを使うのみ、API呼び出しなし
- **ロジック統一**: itemBoards計算を親に集約

### 期待される効果

- **パフォーマンス向上**: API呼び出し回数の削減
- **保守性向上**: 変更箇所の集約、重複コード削除
- **安定性向上**: データソースの一本化、不整合の防止
