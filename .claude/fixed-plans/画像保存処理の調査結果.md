# 画像保存処理の調査結果

## 📋 現在の処理フロー

### 1. プレビュー表示（AttachmentGallery）

**場所**: `attachment-gallery.tsx`

#### 既存画像の表示

- `useAttachments` フックで画像一覧を取得（Line 42-46）
- `useEffect` で認証付きBlobURLを生成（Line 70-118）
- `imageUrls` stateでBlobURLを管理
- `loadedIdsRef` で読み込み済みIDを追跡

#### 保存待ち画像（pendingImages）の表示

- `pendingImages` からプレビューURL生成（Line 121-138）
- **重複チェック**: 既に `attachments` に存在するファイル（名前+サイズ）は除外
- `pendingUrls` stateでプレビューURLを管理
- **アップロード中の挙動**: `isUploading=true` 時、`opacity-0` で非表示（Line 305）

**問題点**:

- アップロード中にプレビューが消える（`opacity-0`）
- アップロード完了後、重複表示される可能性

---

### 2. 画像アップロード処理（useAttachmentManager）

**場所**: `use-attachment-manager.ts`

#### uploadPendingImages関数（Line 219-351）

**フロー**:

1. アップロード開始トーストを表示（Line 231-235）
2. `Promise.allSettled` で並列アップロード（Line 237-270）
   - 新規作成時: 直接fetch APIを使用（Line 240-266）
   - 既存メモ: `uploadMutation` を使用（Line 268）
3. 最低3秒表示を保証（Line 284-289）
4. トーストを削除して完了トーストを表示（Line 292-302）
5. **キャッシュ更新**（Line 304-333）:
   - 成功時のみ実行
   - `setPendingImages([])` でpendingをクリア（Line 316）
   - `queryClient.setQueryData` で楽観的更新（Line 318-328）
   - `queryClient.invalidateQueries` でリフェッチ（Line 331）

**問題点**:

- Line 316で `setPendingImages([])` を呼んでいるが、これは親の状態を直接更新できない
- キャッシュ更新のタイミングが複雑（楽観的更新 → invalidate）
- 重複表示の原因: キャッシュ更新前に pendingImages がクリアされていない

---

### 3. メモエディターでの保存処理

**場所**: `memo-editor.tsx` - `handleSaveWithTags`（Line 737-995）

#### 画像のみ保存の特殊ケース（Line 751-872）

1. 空のメモを作成（title=" ", content=""）
2. targetOriginalIdを取得
3. ボード紐付け
4. キャッシュ更新（`invalidateQueries`）

#### 通常の保存処理（Line 873-885）

1. `handleSave()` でメモ保存
2. targetOriginalIdを取得

#### 画像アップロード実行（Line 922-971）

1. `deletePendingAttachments()` - 削除予定を削除
2. `uploadPendingImages(targetOriginalId)` - アップロード実行
3. `invalidateBoardCaches()` - ボードキャッシュ更新（Line 934）
4. 画像のみ保存の場合、作成されたメモを選択（Line 937-969）

**問題点**:

- キャッシュ更新が多重（`invalidateQueries` が複数箇所）
- アップロード後の状態管理が複雑
- pendingImagesのクリアタイミングが不明確

---

## 🔍 特定された問題

### 1. プレビュー表示の問題

- **アップロード中にプレビューが消える**: `opacity-0` による非表示
- **アップロード完了後の重複表示**: pendingImagesのクリアタイミングが遅い

### 2. キャッシュ更新の問題

- **多重invalidate**:
  - memo-editor.tsx: Line 785-787（チームメモ）
  - memo-editor.tsx: Line 841（個人メモ）
  - memo-editor.tsx: Line 934（ボードキャッシュ）
  - memo-editor.tsx: Line 947（画像のみ保存時）
  - use-attachments.ts: Line 106-108（アップロード成功時）
  - use-attachment-manager.ts: Line 331（アップロード完了時）

- **楽観的更新と invalidate の混在**:
  - Line 318-328: `setQueryData` で楽観的更新
  - Line 331: `invalidateQueries` でリフェッチ
  - この組み合わせが重複表示を引き起こす可能性

### 3. 状態管理の問題

- **setPendingImages([])の場所**: use-attachment-manager.ts内（Line 316）
- pendingImagesは親コンポーネント（memo-editor）のstateだが、子フック内でクリアしようとしている
- 実際にはクリアされていない可能性

---

## 💡 改善案

### A. プレビュー表示の改善

- アップロード中も `opacity-0` ではなく、ローディング表示に変更
- または、アップロード中はpendingImagesとして残す

### B. キャッシュ更新の簡素化

1. **楽観的更新を削除**: `setQueryData` を使わず、`invalidateQueries` のみに統一
2. **invalidateの集約**:
   - アップロード完了後の1回のみ
   - 不要な中間invalidateを削除

### C. 状態クリアの明確化

1. **uploadPendingImages の戻り値**: 成功したファイル数を返す
2. **親コンポーネントでクリア**: アップロード成功後、memo-editorで `setPendingImages([])` を実行
3. **use-attachment-manager.ts**: Line 316の `setPendingImages([])` を削除

### D. フローの簡素化案

```typescript
// 1. アップロード実行
const result = await uploadPendingImages(targetOriginalId);

// 2. 成功した場合のみ pendingImages をクリア
if (result.success) {
  setPendingImages([]);
}

// 3. キャッシュ更新は uploadPendingImages 内の1回のみ
//    （中間のinvalidateは削除）
```

---

## 🎯 次のステップ

1. **ユーザーに確認**: どの問題が最も顕著か？
   - プレビューが消える？
   - 重複表示される？
   - リフェッチが遅い？

2. **優先順位を決定**: どの改善を先に実施するか？

3. **段階的に修正**: 一度に全部変えず、1つずつ確認しながら進める

---

最終更新日: 2025-11-11
