# ぺたぼー キャッシュ設計方針

## 作成日: 2024-12-08

## 最終更新: 2024-12-11

## ステータス: ✅ 実装完了（PETABOO-55）

---

## 🎯 設計思想

### 核心のアイデア

```
「すべての変更は保存ボタンを通る」
  ↓
保存処理を共通化すれば、キャッシュ管理も一箇所で済む
  ↓
エンティティ別（タスク/メモ/ボード...）ではなく
「保存」という操作 + itemType で統一的に管理
```

### 旧方針 vs 新方針

| 項目       | 旧方針                                    | 新方針                 | 現状（実装後）  |
| ---------- | ----------------------------------------- | ---------------------- | --------------- |
| 単位       | エンティティ別（use-tasks, use-memos...） | 操作別（共通保存処理） | ✅ 統一済み     |
| 管理箇所   | 各hooksファイル（分散）                   | 共通保存処理（集約）   | ✅ cache-utils  |
| invalidate | 307箇所                                   | ほぼゼロ               | 148箇所（-52%） |
| パターン   | ファイルごとに微妙に違う                  | 統一                   | ✅ 統一済み     |

---

## 🎯 最終ゴール

### 数値目標

| 項目              | 修正前  | 現状     | ゴール |
| ----------------- | ------- | -------- | ------ |
| invalidateQueries | 307箇所 | 148箇所  | 10以下 |
| refetchQueries    | 多数    | ほぼ削除 | 0      |
| setQueryData      | 少数    | 53箇所   | 増加   |

### 許可される invalidate

| 場面                    | 理由           |
| ----------------------- | -------------- |
| 一括操作（6件以上）     | 個別更新が複雑 |
| CSVインポート           | 大量データ     |
| 競合検知後（409エラー） | 整合性回復     |
| タグ付け変更            | 複数箇所に影響 |

---

## 📐 アーキテクチャ

### 統一保存ルート

```
ユーザー操作（作成/更新/削除/復元）
        ↓
    保存ボタン
        ↓
┌─────────────────────────────────────┐
│         共通保存処理                  │
│                                     │
│  itemType で分岐:                    │
│  - "task"                           │
│  - "memo"                           │
│  - "board"                          │
│                                     │
│  1. 楽観的更新（setQueryData）        │
│     - 該当アイテムのキャッシュのみ更新  │
│                                     │
│  2. API呼び出し                      │
│     - updatedAt を送信（チームモード） │
│                                     │
│  3. レスポンス処理                    │
│     - 成功 → 完了                    │
│     - 409 → トースト + 最新データ反映  │
│     - エラー → ロールバック           │
└─────────────────────────────────────┘
```

### 型定義

```typescript
// アイテム種別
type ItemType = "task" | "memo";

// キャッシュキーの生成
const getCacheKey = (itemType: ItemType, teamId?: number) => {
  if (teamId) {
    return [`team-${itemType}s`, teamId]; // ["team-tasks", 123]
  }
  return [itemType === "task" ? "tasks" : "memos"]; // ["tasks"] or ["memos"]
};

const getDeletedCacheKey = (itemType: ItemType, teamId?: number) => {
  if (teamId) {
    return [`team-deleted-${itemType}s`, teamId];
  }
  return itemType === "task" ? ["deleted-tasks"] : ["deletedMemos"];
};
```

### キャッシュ更新の原則

```typescript
// 保存成功時: 該当アイテムのみ更新
queryClient.setQueryData(
  getCacheKey(itemType, teamId),
  (old) => 該当アイテムのみ更新した新配列,
);

// invalidate は使わない（例外を除く）
```

### 取得時のキャッシュ設定（useQuery）

個人モードでは `setQueryData` で常に最新化されるため、ページ遷移時のAPI再取得は不要。

```typescript
// 個人モード用設定
{
  staleTime: Infinity,        // 永続キャッシュ（setQueryDataで更新）
  refetchOnMount: false,      // マウント時に再取得しない
  refetchOnWindowFocus: false // フォーカス時に再取得しない
}

// チームモード用設定
{
  staleTime: 30 * 1000,       // 30秒（他メンバーの変更取得のため短め）
  refetchOnMount: true,       // マウント時に再取得
  refetchOnWindowFocus: false,
  refetchInterval: 60 * 1000  // 60秒ごとに自動取得
}
```

| 設定                 | 個人モード | チームモード |
| -------------------- | ---------- | ------------ |
| staleTime            | Infinity   | 30秒         |
| refetchOnMount       | false      | true         |
| refetchOnWindowFocus | false      | false        |
| refetchInterval      | なし       | 60秒         |

---

## 🚀 実装ステップ

### Step 1: 個人モード（シンプル） ✅ 完了

```
目標: 保存 → setQueryData のみ

やったこと:
- cache-utils.ts に updateItemCache 関数を作成
- 各hooks（use-tasks, use-memos等）で共通関数を使用
- 過剰な invalidate/refetch を削除
```

### Step 2: チームモード（個人と同じ） ✅ 完了

```
目標: まず個人モードと同じ仕組みにする

やったこと:
- チーム用hooksも同じパターンに統一
- updateItemCache を teamId 対応
```

### Step 3: チームモード（競合チェック追加） ✅ 完了

```
目標: 楽観的ロックで競合検知

やったこと:
- API側: teams/tasks.ts, teams/memos.ts に競合チェック実装
- フロント側: use-simple-item-save.ts で updatedAt を送信
- 409エラー時: トースト表示（5秒）+ 最新データでキャッシュ更新
```

### Step 4: チームモード（定期取得） ✅ 既存

```
目標: 他人の変更を取得

状態:
- refetchInterval: 60秒（既存のままでOK）
- staleTime: 30秒
```

---

## 📝 共通キャッシュ更新関数

### updateItemCache ✅ 実装済み（apps/web/src/lib/cache-utils.ts）

```typescript
// apps/web/src/lib/cache-utils.ts

type ItemType = "task" | "memo";
type Operation = "create" | "update" | "delete" | "restore" | "permanentDelete";

interface UpdateItemCacheParams {
  queryClient: QueryClient;
  itemType: ItemType;
  operation: Operation;
  item: Task | Memo;
  teamId?: number;
  boardId?: number;
}

export const updateItemCache = ({
  queryClient,
  itemType,
  operation,
  item,
  teamId,
  boardId,
}: UpdateItemCacheParams) => {
  const cacheKey = getCacheKey(itemType, teamId);
  const deletedCacheKey = getDeletedCacheKey(itemType, teamId);

  switch (operation) {
    case "create":
      // 一覧に追加
      queryClient.setQueryData(cacheKey, (old) => [...(old || []), item]);
      break;

    case "update":
      // 一覧の該当アイテムを置換
      queryClient.setQueryData(cacheKey, (old) =>
        old?.map((i) => (i.id === item.id ? item : i)),
      );
      break;

    case "delete":
      // 一覧から削除 + 削除済みに追加
      queryClient.setQueryData(cacheKey, (old) =>
        old?.filter((i) => i.id !== item.id),
      );
      queryClient.setQueryData(deletedCacheKey, (old) => [
        ...(old || []),
        item,
      ]);
      break;

    case "restore":
      // 削除済みから削除 + 一覧に追加
      queryClient.setQueryData(deletedCacheKey, (old) =>
        old?.filter((i) => i.id !== item.id),
      );
      queryClient.setQueryData(cacheKey, (old) => [...(old || []), item]);
      break;

    case "permanentDelete":
      // 削除済みから削除のみ
      queryClient.setQueryData(deletedCacheKey, (old) =>
        old?.filter((i) => i.id !== item.id),
      );
      break;
  }

  // ボード連携
  if (boardId) {
    updateBoardItemCache({
      queryClient,
      boardId,
      itemType,
      operation,
      item,
      teamId,
    });
  }
};
```

### updateBoardItemCache ✅ 実装済み

```typescript
export const updateBoardItemCache = ({
  queryClient,
  boardId,
  itemType,
  operation,
  item,
  teamId,
}: {
  queryClient: QueryClient;
  boardId: number;
  itemType: ItemType;
  operation: Operation;
  item: Task | Memo;
  teamId?: number;
}) => {
  const boardCacheKey = teamId
    ? ["team-boards", teamId.toString(), boardId, "items"]
    : ["boards", boardId, "items"];

  const boardDeletedCacheKey = teamId
    ? ["team-board-deleted-items", teamId.toString(), boardId]
    : ["board-deleted-items", boardId];

  switch (operation) {
    case "create":
    case "restore":
      queryClient.setQueryData(boardCacheKey, (old) => [
        ...(old || []),
        { type: itemType, item },
      ]);
      break;

    case "update":
      queryClient.setQueryData(boardCacheKey, (old) =>
        old?.map((i) =>
          i.type === itemType && i.item.id === item.id ? { ...i, item } : i,
        ),
      );
      break;

    case "delete":
      queryClient.setQueryData(boardCacheKey, (old) =>
        old?.filter((i) => !(i.type === itemType && i.item.id === item.id)),
      );
      break;
  }
};
```

---

## 🔒 競合チェック（チームモード - Step 3） ✅ 実装済み

### API側（インライン実装）

teams/tasks.ts, teams/memos.ts の PUT ハンドラー内で直接実装:

```typescript
// 楽観的ロック: updatedAt を抽出して競合チェック
const { updatedAt: clientUpdatedAt, ...rest } = parsed.data;

if (clientUpdatedAt !== undefined) {
  const current = await db.select({ updatedAt }).from(table).where(...).get();

  if (current.updatedAt !== clientUpdatedAt) {
    const latestData = await db.select(...).get();
    return c.json({
      error: "Conflict",
      message: "他のメンバーが変更しました",
      latestData,
    }, 409);
  }
}
```

### フロント側（409ハンドリング） ✅ 実装済み

use-tasks.ts, use-memos.ts の onError で処理:

```typescript
onError: (error: Error & { status?: number; latestData?: Task }) => {
  if (error.status === 409 && error.latestData) {
    showToast(
      "他のメンバーが変更しました。最新の内容を表示します。",
      "warning",
      5000,
    );
    updateItemCache({
      queryClient,
      itemType: "task",
      operation: "update",
      item: error.latestData,
      teamId,
    });
  }
};
```

---

## 🚫 禁止事項

```typescript
// ❌ invalidate + refetch の併用
queryClient.invalidateQueries(["tasks"]);
queryClient.refetchQueries(["tasks"]);

// ❌ predicateによる広範囲マッチ
queryClient.invalidateQueries({
  predicate: (query) => query.queryKey[0] === "boards",
});

// ❌ setTimeoutでの遅延refetch
setTimeout(() => queryClient.refetchQueries(["tasks"]), 1000);

// ❌ keepPreviousData: true（一覧系）
// ❌ エンティティ別にバラバラな実装
```

---

## ✅ チェックリスト

### 新しいmutation追加時

- [ ] 共通の updateItemCache を使っているか
- [ ] invalidateQueries を使っていないか（例外除く）
- [ ] refetchQueries を使っていないか
- [ ] ボード連携がある場合、boardId を渡しているか
- [ ] チームモードで updatedAt を送信しているか
- [ ] 409エラー時のハンドリングがあるか

---

## 📁 関連ファイル

### 実装済み

- `apps/web/src/lib/cache-utils.ts` - 共通キャッシュ更新関数 ✅
- `apps/api/src/middleware/conflict-check.ts` - 競合チェック（未使用、インライン実装済み）

### 完了したPlan

- `.claude/fixed-plans/PETABOO-55_step1_個人モード.md`
- `.claude/fixed-plans/PETABOO-55_step2_チームモード.md`
- `.claude/fixed-plans/PETABOO-55_step3_競合チェック.md`

### キャッシュ関連の主要ファイル

| ファイル                | 役割               | 状態             |
| ----------------------- | ------------------ | ---------------- |
| cache-utils.ts          | 共通キャッシュ更新 | ✅ 新規作成      |
| use-tasks.ts            | タスクCRUD         | ✅ 409対応済み   |
| use-memos.ts            | メモCRUD           | ✅ 409対応済み   |
| use-simple-item-save.ts | 統一保存処理       | ✅ updatedAt送信 |
| teams/tasks.ts (API)    | チームタスク更新   | ✅ 競合チェック  |
| teams/memos.ts (API)    | チームメモ更新     | ✅ 競合チェック  |

---

## 🔮 残りの課題（将来対応）

### 優先度: 中

| 課題                     | 現状                      | 対応案                                      |
| ------------------------ | ------------------------- | ------------------------------------------- |
| 競合時のフォーム処理     | 警告のみ、入力は破棄      | 下書き保存 or フォーム上書き                |
| refetch後のupdatedAt問題 | 古いupdatedAtで保存される | フォームにupdatedAt持たせる or 再取得時更新 |

### 別問題として切り出し（保存ボタンを噛まない操作）

以下は「保存ボタン」を使わない操作のため、キャッシュ設計の統一対象外。
別途検討が必要。

| 分類                 | ファイル                   | invalidate残存 | 備考                                   |
| -------------------- | -------------------------- | -------------- | -------------------------------------- |
| タグ自体の操作       | use-tags.ts                | 7箇所          | タグ作成・編集・削除（保存ボタンなし） |
| ~~タグ紐づけ操作~~   | ~~use-taggings.ts~~        | ~~0箇所~~      | ✅ setQueryData化完了                  |
| ~~チームタグ紐づけ~~ | ~~use-team-taggings.ts~~   | ~~0箇所~~      | ✅ setQueryData化完了                  |
| チームタグ自体       | use-team-tags.ts           | 5箇所          | チームタグ作成・編集・削除             |
| 通知                 | use-notifications.ts       | 2箇所          | 通知既読など                           |
| Slack設定            | use-team-slack-config.ts   | 2箇所          | Slack連携設定                          |
| ボードSlack設定      | use-board-slack-config.ts  | 2箇所          | ボード単位のSlack設定                  |
| CSVインポート        | use-tasks.ts, use-memos.ts | 2箇所          | 大量データ一括処理（invalidate許容）   |
| チームコメント       | use-team-comments.ts       | 9箇所          | コメントCRUD                           |
| チーム管理           | use-create-team.ts等       | 複数           | チーム作成・招待・参加リクエストなど   |
| カテゴリ             | use-categories.ts          | 3箇所          | カテゴリ操作                           |
| ボードカテゴリ       | use-board-categories.ts    | 4箇所          | ボードカテゴリ操作                     |
| 統一復元             | use-unified-restoration.ts | 8箇所          | 削除アイテム復元                       |

### 優先度: 低（様子見）

| 項目         | 理由                         |
| ------------ | ---------------------------- |
| 差分API      | 楽観的ロックで十分           |
| rev方式      | 複雑化のわりにメリット少ない |
| 編集中ロック | 接続管理が複雑、今は過剰     |
| WebSocket    | Cloudflare Workersでは複雑   |

---

## 📊 改善実績（PETABOO-55）

| 指標                      | 修正前  | Step1-3後    | Step4後 | 変化   |
| ------------------------- | ------- | ------------ | ------- | ------ |
| invalidate/refetch        | 307箇所 | 148箇所      | 76箇所  | -75%   |
| `["boards", "all-items"]` | 8回     | 2回          | 0回     | -100%  |
| `["boards"]` 過剰         | 3回     | 0回          | 0回     | -100%  |
| setQueryData              | 少数    | 53箇所       | 増加    | 大幅増 |
| タスク一覧消えるバグ      | 発生    | 解消         | 解消    | ✅     |
| 競合検出                  | なし    | 409+トースト | 同左    | ✅     |
| placeholderData問題       | あり    | 個人のみ解消 | 全解消  | ✅     |

### Step4で対応した内容（2024-12-10）

- `placeholderData: []` を全て削除（5箇所）
- チームモードの `invalidate + refetch` パターンを `setQueryData` に統一
- タスク/メモ操作時の不要なタグinvalidateを削除
- `use-taggings.ts` の `setQueryData` 化完了（個人タグ紐づけ）
- `use-team-taggings.ts` の `setQueryData` 化完了（チームタグ紐づけ）

### Step5で対応した内容（2024-12-11）

- `use-team-taggings.ts` のキャッシュキー修正（`["team-tags", teamId]` → `["team-tags", teamId, {}]`）
  - チームタグ付け作成時にタグ情報が取得できない問題を修正
- デバッグログの削除（`use-team-taggings.ts`, `task-editor.tsx`, `board-right-panel.tsx`）

### 設計方針の明確化

| 操作種別       | 方式              | 理由                         |
| -------------- | ----------------- | ---------------------------- |
| タグ紐づけ     | setQueryData      | 保存ボタンに統合されている   |
| タグ自体の操作 | invalidateQueries | 保存ボタンを噛まない即時操作 |
