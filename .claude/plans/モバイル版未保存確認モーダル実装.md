# モバイル版未保存確認モーダル実装計画

> ⚠️ Codexに実装依頼する際は、以下を厳守すること：

- **既存ファイルを丸ごと再生成させないこと**
  → Codexへの依頼は必ず **差分（patch形式）** で行う
- **日本語コメント・文字列を扱う場合はUTF-8前提で依頼すること**
  → 文字化け防止のため明記する
- **Codexに git add / git commit を実行させないこと**
- **完了した場合ファイルを`.claude/fixed-plans` に移動する**

---

## 目的

モバイル版チームボード詳細画面で、メモ/タスクエディターに未保存の変更がある場合、フッターの戻るボタン押下時に確認モーダルを表示する。

### 期待成果

- モバイルユーザーが誤って未保存の変更を破棄することを防止
- PC版と同等のUXを提供

---

## 背景・問題点

### 現状の問題

1. モバイル版の戻るボタンは `Sidebar`（フッター）にあり、`MemoEditor` とは別階層
2. 戻るボタン押下 → `team-back-to-memo-list` イベント発火 → `team-detail.tsx` が即座に `setSelectedMemo(null)` を実行
3. **MemoEditor が介入する機会がなく、未保存確認ができない**

### 解決アプローチ

**TeamDetailContext を活用**して、Sidebar から直接未保存状態を確認し、モーダル表示を制御する。

既存の Context に以下の ref が既にある：

- `memoEditorHasUnsavedChangesRef` - 未保存変更の有無
- `memoEditorShowConfirmModalRef` - モーダル表示関数

---

## 変更範囲

| ファイル                                            | 変更内容                                    |
| --------------------------------------------------- | ------------------------------------------- |
| `apps/web/components/layout/sidebar.tsx`            | 戻るボタンで Context 経由の未保存チェック   |
| `apps/web/components/features/memo/memo-editor.tsx` | handleConfirmClose でモバイル用イベント発火 |
| `apps/web/components/features/task/task-editor.tsx` | 同上（タスク版）                            |

**※ team-detail-context.tsx の変更は不要**（既存の ref で対応可能）

---

## 実装手順

### Step 1: Sidebar で戻るボタン処理を修正

**ファイル**: `apps/web/components/layout/sidebar.tsx`

#### 1-1. トップレベルで useTeamDetailSafe を呼び出し

```typescript
// 既存の import に追加
import { useTeamDetailSafe } from "@/src/contexts/team-detail-context";

// コンポーネント内のトップレベルで取得
const teamDetailContext = useTeamDetailSafe();
```

#### 1-2. メモエディター用 onBack を修正（242-248行目付近）

**現在のコード**:

```typescript
onBack={() => {
  if (isTeamMode) {
    window.dispatchEvent(new CustomEvent("team-back-to-memo-list"));
  }
  // TODO: 個人モードの戻るボタン処理（未実装）
}}
```

**修正後**:

```typescript
onBack={() => {
  if (isTeamMode) {
    // Context から未保存状態を確認
    if (teamDetailContext) {
      const hasUnsaved = teamDetailContext.memoEditorHasUnsavedChangesRef.current;
      if (hasUnsaved) {
        // 未保存変更あり → モーダル表示して終了
        teamDetailContext.memoEditorShowConfirmModalRef.current?.();
        return;
      }
    }
    // 未保存変更なし → 通常の閉じる処理
    window.dispatchEvent(new CustomEvent("team-back-to-memo-list"));
  }
  // TODO: 個人モードの戻るボタン処理（未実装）
}}
```

#### 1-3. タスクエディター用 onBack を修正（191-198行目付近）

**現在のコード**:

```typescript
onBack={() => {
  const backEventName = showingBoardDetail
    ? "board-task-back"
    : isTeamMode
      ? "team-back-to-task-list"
      : "task-editor-mobile-back-requested";

  window.dispatchEvent(new CustomEvent(backEventName));
}}
```

**修正後**:

```typescript
onBack={() => {
  // チームモードの場合、未保存チェック
  if (isTeamMode && teamDetailContext) {
    const hasUnsaved = teamDetailContext.taskEditorHasUnsavedChangesRef.current;
    if (hasUnsaved) {
      // 未保存変更あり → モーダル表示して終了
      teamDetailContext.taskEditorShowConfirmModalRef.current?.();
      return;
    }
  }

  // 未保存変更なし → 通常の閉じる処理
  const backEventName = showingBoardDetail
    ? "board-task-back"
    : isTeamMode
      ? "team-back-to-task-list"
      : "task-editor-mobile-back-requested";

  window.dispatchEvent(new CustomEvent(backEventName));
}}
```

### Step 2: MemoEditor の handleConfirmClose を修正

**ファイル**: `apps/web/components/features/memo/memo-editor.tsx`

**現在のコード（1149-1158行目付近）**:

```typescript
const handleConfirmClose = useCallback(() => {
  setIsCloseConfirmModalOpen(false);
  dispatchDiscardEvent("memo");
  setTimeout(() => {
    onClose();
  }, 50);
}, [onClose]);
```

**修正後**:

```typescript
const handleConfirmClose = useCallback(() => {
  setIsCloseConfirmModalOpen(false);
  dispatchDiscardEvent("memo");

  // モバイル版チームモードの場合はイベント発火で閉じる
  const isMobile = typeof window !== "undefined" && window.innerWidth < 768;
  if (isMobile && teamMode) {
    window.dispatchEvent(new CustomEvent("team-back-to-memo-list"));
  } else {
    // PC版は従来通り
    setTimeout(() => {
      onClose();
    }, 50);
  }
}, [onClose, teamMode]);
```

### Step 3: TaskEditor の handleConfirmClose を修正

**ファイル**: `apps/web/components/features/task/task-editor.tsx`

MemoEditor と同様のロジックで修正。イベント名は `team-back-to-task-list` を使用。

---

## 処理フロー図

### 未保存変更あり → 破棄を選択

```
戻るボタンクリック（Sidebar の onBack）
  ↓
teamDetailContext.memoEditorHasUnsavedChangesRef.current = true
  ↓
teamDetailContext.memoEditorShowConfirmModalRef.current() 実行
  ↓
return（ここで処理終了、イベントは発火されない）
  ↓
MemoEditor 内でモーダル表示
  ↓
ユーザーが「閉じる」ボタンを押す
  ↓
handleConfirmClose 実行
  - team-back-to-memo-list イベント発火
  ↓
team-detail.tsx の handleBackToMemoList が実行
  - setSelectedMemo(null)
  - handleTabChange("memos")
  ↓
エディターが閉じる
```

### 未保存変更あり → キャンセルを選択

```
戻るボタンクリック（Sidebar の onBack）
  ↓
モーダル表示
  ↓
ユーザーが「キャンセル」を押す
  ↓
setIsCloseConfirmModalOpen(false)
  ↓
エディターは開いたまま
```

### 未保存変更なし

```
戻るボタンクリック（Sidebar の onBack）
  ↓
teamDetailContext.memoEditorHasUnsavedChangesRef.current = false
  ↓
team-back-to-memo-list イベント発火
  ↓
team-detail.tsx の handleBackToMemoList が実行
  ↓
エディターが閉じる
```

---

## 影響範囲・懸念点

### 影響範囲

1. **チームモードのモバイル版のみ** - 個人モードは対象外（TODO）
2. **メモエディター・タスクエディター両方**

### 懸念点

1. **モバイル判定**
   - `window.innerWidth < 768` での判定
   - Tailwind の md ブレークポイントと一致

2. **個人モード未対応**
   - 個人モードは TeamDetailContext が使えないため、別途対応が必要

3. **ボード詳細のタスク**
   - `showingBoardDetail` の場合のイベント名が `board-task-back` になっている
   - この場合も未保存チェックが効くか確認が必要

---

## テスト項目

- [ ] モバイル版チームメモ一覧でメモを編集中に戻るボタン → モーダル表示
- [ ] モーダルで「閉じる」→ 一覧に戻る
- [ ] モーダルで「キャンセル」→ エディターは開いたまま
- [ ] 変更なしで戻るボタン → モーダルなしで一覧に戻る
- [ ] タスクエディターでも同様の動作
- [ ] ボード詳細画面でも同様の動作
- [ ] PC版の動作に影響がないこと

---

## Codex用ToDoリスト

1. [ ] `sidebar.tsx` のトップレベルで `useTeamDetailSafe()` を import して呼び出し
2. [ ] `sidebar.tsx` のメモエディター用 `onBack`（242-248行目付近）で未保存チェックロジックを追加
3. [ ] `sidebar.tsx` のタスクエディター用 `onBack`（191-198行目付近）で未保存チェックロジックを追加
4. [ ] `memo-editor.tsx` の `handleConfirmClose` を修正（モバイル+チームモード時はイベント発火）
5. [ ] `task-editor.tsx` の `handleConfirmClose` を修正（同上）
6. [ ] 型チェック: `npm run check:wsl`
